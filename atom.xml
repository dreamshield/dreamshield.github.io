<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric的技术咖啡屋</title>
  <icon>https://www.gravatar.com/avatar/8e7764432bd2e4402b45b1dcc09c40ec</icon>
  <subtitle>未来有信心，长期有耐心。</subtitle>
  <link href="https://techcoffe.com/atom.xml" rel="self"/>
  
  <link href="https://techcoffe.com/"/>
  <updated>2020-08-22T14:15:10.000Z</updated>
  <id>https://techcoffe.com/</id>
  
  <author>
    <name>EricZhang</name>
    <email>zhpf@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式总结</title>
    <link href="https://techcoffe.com/2020/08/22/Summary-of-Singleton-Pattern/"/>
    <id>https://techcoffe.com/2020/08/22/Summary-of-Singleton-Pattern/</id>
    <published>2020-08-22T03:36:32.000Z</published>
    <updated>2020-08-22T14:15:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是大家平时经常在工程中见到与使用的一种设计模式。本文的目的是介绍单例模式的各种实现方式以及每种实现方式涉及到的问题点。首先我们看下单例模式的定义。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>单例模式：保证一个类仅有一个示例，并提供一个访问它的全局访问点。</p><blockquote><p>通常我们可以让一个全局变量使得一个变量被访问，但它不能防止你实例化多个对象。一个最好的方法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其它实例能够被创建，并且它可以提供一个访问该实例的方法。</p></blockquote><p>单例模式的uml图如下所示：<br><img src="/img/2020/8/singleton.png" alt="图1-单例模式" width="60%"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>考虑到不同的使用场景与环境，单例模式的实现也是多种多样，需要我们根据具体的场景进行相应的选择。接下来就对不同场景下单例模式的实现以及每种实现方式的存在的问题进行介绍。</p><a id="more"></a><h3 id="方式1：单线程"><a href="#方式1：单线程" class="headerlink" title="方式1：单线程"></a>方式1：单线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 语句①</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式实现简单明了，但是只能用在单线程的环境中，如果有多个线程同时访问getInstance方法，并且同时执行语句①，由于语句①形成一个check-then-act操作，他不是一个原子操作。这时每个线程的if判断结果均为true，那么将产生多个Singleton实例，单例模式实效。为了实现线程安全，很自然的想到使用synchronized关键字。也就是我们下面实现的多线程版本一。</p><h3 id="方式2：多线程-耗性能版"><a href="#方式2：多线程-耗性能版" class="headerlink" title="方式2：多线程(耗性能版)"></a>方式2：多线程(耗性能版)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonMultiThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonMultiThread instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonMultiThread</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonMultiThread <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 语句①</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonMultiThread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式通过synchronized关键字，避免了多线程环境下线程不安全的问题，保证了单例模式的正确性。但于此同时每一次对getInstance的访问都要加锁。由于加锁访问对性能损耗是极大的，因此虽然该模式保证了单例模式在多线程环境下的线程安全，但也是以降低性能为代价换取的。为了减少加锁性能的开销，人们想到了一个聪明的方法，只有在instance为null的时候才进行加锁操作。就是下面的实现方式DCL(Double Check Lock)版本。</p><h3 id="方式3：多线程-DCL-非安全发布版"><a href="#方式3：多线程-DCL-非安全发布版" class="headerlink" title="方式3：多线程(DCL-非安全发布版)"></a>方式3：多线程(DCL-非安全发布版)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncorrectDCLSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IncorrectDCLSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IncorrectDCLSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IncorrectDCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//操作①</span></span><br><span class="line">            <span class="keyword">synchronized</span> (IncorrectDCLSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//操作②</span></span><br><span class="line">                    instance = <span class="keyword">new</span> IncorrectDCLSingleton(); <span class="comment">//操作③</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看上面的代码既避免了锁的开销又保证了线程安全：一个线程T1执行到操作①的时候发现instance为null(第1次check)，而此时另一个线程T2可能恰好刚执行完操作③而使instance不为null；接着T1获得锁而执行临界区的代码，再一次判断instance值是否为null(第2次check)，此时由于该线程是在临界区内读取共享变量instance，因此T1此时发现instance值已经不为null，于是T1不会执行操作③(创建实例)，从而避免了再次创建一个新实例。当然，仅从可见性的角度分析结论确实如此。但是，在一些情形下为了确保线程安全光考虑可见性是不够的，还要考虑重排序对线程安全的影响。</p><p>我们知道操作③可以分解为如下伪代码所示的几个独立操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objRef &#x3D; allocate(IncorrectDCLSingleton.class); &#x2F;&#x2F; 子操作①：分配对象所需的存储空间</span><br><span class="line">invokeConstructor(objRef); &#x2F;&#x2F; 子操作②：初始化objRef引用的对象</span><br><span class="line">instance &#x3D; objRef; &#x2F;&#x2F; 子操作③：将对象引用写入共享变量</span><br></pre></td></tr></table></figure><p>根据锁的重排序规则，临界区内的操作可以在临界区内进行重排序。因此，JIT编译器可能将上述的子操作重排序为：子操作① -&gt; 子操作③ -&gt; 子操作②，记在初始化对象之前将对象的引用写入实例变量instance。由于锁对有序性的保障是有条件的，而操作①(第一次检查)读取instance变量的时候并没有加锁，因此上述排序对操作①的执行线程是有影响的：该线程可能看到一个为初始化(或未初始化完毕)的实例，即变量instance的值不为null，但是该变量所引用的对象中的某些实例变量的值可能仍然是默认值，而不是构造器中设置的初始值。也就是说，一个线程在执行操作①的时候发现instance不为null，于是该线程就直接返回这个instance变量所引用的实例，而这个实例可能未初始化完毕，这就可能导致程序错误。通过上面的分析，解决方法也就不难想到：只需要将instance变量采用volatile修饰即可。详见单例实现方式4-多线程DCL版。</p><h3 id="方式4：多线程-DCL版"><a href="#方式4：多线程-DCL版" class="headerlink" title="方式4：多线程(DCL版)"></a>方式4：多线程(DCL版)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//操作①</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DCLSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//操作②</span></span><br><span class="line">                    instance = <span class="keyword">new</span> DCLSingleton(); <span class="comment">//操作③</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式实际上是利用了关键字volatile的一下两个特性：</p><ul><li>保证可见性：一个线程通过执行操作③修改了instance变量的值，其它线程可以读取到相应的值(通过执行操作①)。</li><li>保障有序性：由于volatile能够禁止volatile变量写操作与该操作之前的任何读、写操作进行重排序，因此用volatile修饰instance相当于禁止JIT编译器以及处理器将子操作②(对对象进行初始化子操作)重排序到子操作③(将对象引用写入共享变量的写操作)，这保障了一个线程读取到instance变量所引用的实例时该实例已经初始化完毕。</li></ul><h3 id="方式5：内部类"><a href="#方式5：内部类" class="headerlink" title="方式5：内部类"></a>方式5：内部类</h3><p>考虑到DCL实现方式容易出错，还有一种同样可以实现延迟加载同时保证线程安全的简单方式，即基于内部类的实现方式，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> InnerClassSingleton INSTANCE = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> do...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClassSingleton.getInstance().doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于类的静态变量被初次访问的时候会触发Java虚拟机对该类进行初始化，即该类的静态变量值会变为其初始值而不是默认值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://book.douban.com/subject/27034721//">Java多线程编程实战指南-核心篇</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;单例模式是大家平时经常在工程中见到与使用的一种设计模式。本文的目的是介绍单例模式的各种实现方式以及每种实现方式涉及到的问题点。首先我们看下单例模式的定义。&lt;/p&gt;
&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h2&gt;&lt;p&gt;单例模式：保证一个类仅有一个示例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常我们可以让一个全局变量使得一个变量被访问，但它不能防止你实例化多个对象。一个最好的方法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其它实例能够被创建，并且它可以提供一个访问该实例的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式的uml图如下所示：&lt;br&gt;&lt;img src=&quot;/img/2020/8/singleton.png&quot; alt=&quot;图1-单例模式&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;模式实现&quot;&gt;&lt;a href=&quot;#模式实现&quot; class=&quot;headerlink&quot; title=&quot;模式实现&quot;&gt;&lt;/a&gt;模式实现&lt;/h2&gt;&lt;p&gt;考虑到不同的使用场景与环境，单例模式的实现也是多种多样，需要我们根据具体的场景进行相应的选择。接下来就对不同场景下单例模式的实现以及每种实现方式的存在的问题进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://techcoffe.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的volatile与final</title>
    <link href="https://techcoffe.com/2019/05/30/Volatile-and-Final-in-Java/"/>
    <id>https://techcoffe.com/2019/05/30/Volatile-and-Final-in-Java/</id>
    <published>2019-05-30T00:25:54.000Z</published>
    <updated>2024-06-18T04:48:34.792Z</updated>
    
    <content type="html"><![CDATA[<p>Java在并发并发编程中，实现各个线程之间的安全可靠通信中，volatile、synchronized与final这三个原语起到了关键作用。可以说是Java在语言层面实现并发编程线程安全的基石。其中volatile与final更是基础中的基础，本文记录笔者在学习关于这部分一些整理。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当声明共享变量为volatile变量时，对这个变量的读、写将会变得很特别。特别之处主要体现在两个方面：其自身特性与其对内存可见性的影响。</p><a id="more"></a><h3 id="volatile自身特性"><a href="#volatile自身特性" class="headerlink" title="volatile自身特性"></a>volatile自身特性</h3><p>对一个volatile变量的读/写操作，与对一个普通变读/写操作使用同一个锁来同步，它们之间的执行效果相同。锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。volatile读写示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将val声明为64位volatile long型变量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> val = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个volatile变量写 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个volatile变量读 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 符合volatile读写(Read-Modify-Write) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* VolatileFeaturesExample与下面的CommonSyncExample等价*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonSyncExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将val声明为64位普通long型变量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> val = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个普通变量写(锁同步) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个普通变量读(锁同步) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 普通变量读写(Read-Modify-Write) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> temp = getVal();</span><br><span class="line">        temp += <span class="number">1L</span>;</span><br><span class="line">        setVal(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>对volatile自身的特性总结如下:</p><blockquote><p>可见性：对一个volatile变量的读，总能看到(任意线程)对这个volatile变量最后的写入；<br>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种符合操作不具有原子性。</p></blockquote><h3 id="volatile对内存可见性的影响"><a href="#volatile对内存可见性的影响" class="headerlink" title="volatile对内存可见性的影响"></a>volatile对内存可见性的影响</h3><p>volatile变量对可见性的影响比volatile变量本身更为重要。从JSR-133开始(即从JDK5开始)，volatile变量的写-读可以实现线程之间的通信。当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的。因此，从内存可见性(内存语义)的角度来看，volatile变量的读/写与锁的释放/获取具有相同的内存效果。</p><ul><li>volatile变量的写和锁的释放有相同的内存语义(冲刷处理器缓存)；<blockquote><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></blockquote></li><li>volatile变量的读和锁的获取有相同的内存语义(刷新处理器缓存)。<blockquote><p>当独一个volatile变量时，JMM会把该线程对应的本地内存置为无效(使无效化队列内容立即生效)，线程将从主内存中读取共享变量。</p></blockquote></li></ul><p>volatile变量的内存语义具体如何实现这里不做展开，详细内容可以参考<a href="https://www.infoq.cn/article/java_memory_model">深入理解Java内存模型</a>中所讲的内容。</p><p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。然而如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难理解。在有限的一些情形下使用volatile变量替代锁。要使 volatile变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>对变量的写操作不依赖于当前值；</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><blockquote><p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括: ①确保它们自身状态的可见性，②确保它们所引用对象的状态的可见性；③以及标识一些重要的程序生命周期事件的发生。</p></blockquote><h3 id="volatile变量使用的典型模式"><a href="#volatile变量使用的典型模式" class="headerlink" title="volatile变量使用的典型模式"></a>volatile变量使用的典型模式</h3><p>volatile变量的使用典型模式可以参考参考资料[4]中的具体内容，以下对两个最常用的场景给出示例，volatile做为状态标志与安全发布。</p><p><strong>模式1：检查某个状态标志</strong></p><blockquote><p>该模式利用volatile变量的可见性与原子性，保证了对状态标志在多线程环境性下的正确读取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    shutdownRequested = <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式2：安全发布对象</strong></p><blockquote><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flooble</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> foo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Flooble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bar = <span class="number">1</span>;</span><br><span class="line">        foo = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 其他</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// 操作①：进行对象的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) <span class="comment">// 操作②：读取theFlooble变量并判断</span></span><br><span class="line">                doSomething(floobleLoader.theFlooble); <span class="comment">// 操作③：使用theFlooble进行业务处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设对initInBackground方法与doWork方法分别由线程A和线程B两个不同的线程执行。initInBackground方法只有一条语句:<br><code>theFlooble = new Flooble();</code>该语句可以分解为以下三个子操作(伪代码表示):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子操作①：分配Flooble实例所需的内存空间，并获得一个指向该空间的引用</span></span><br><span class="line">objRef = allocate(Flooble.class);</span><br><span class="line"><span class="comment">// 子操作②：调用Flooble类的构造器初始化objRef引用指向的Flooble实例</span></span><br><span class="line">invokeConstructor(objRef);</span><br><span class="line"><span class="comment">// 子操作③：将Flooble实例引用的objRef赋值给变量theFlooble</span></span><br><span class="line">theFlooble = objRef;</span><br></pre></td></tr></table></figure><p>假设theFlooble为普通变量不是volatile变量，那么由于JIT编译器可能将上述的子操作从排序为：子操作①-&gt;子操作③-&gt;子操作②，即在初始化对象完成之前将Flooble对象的引用写入实例变量theFlooble。那么线程B在执行doWork方法时，虽然floobleLoader.theFlooble变量值已经不为null，但此时获得的可能是一个未被完全初始化的实例。即该变量所引用的对象中的某些实例变量的变量值可能仍然是默认值，而不是构造其中设置的值。</p><p>由于theFlooble是volatile变量，因此同时保障该共享变量的可见性与有序性。</p><ul><li>可见性：线程A通过操作①修改了theFlooble变量的值，其它线程(编程B)可以读取到相应的值(通过操作②);</li><li>有序性：由于volatile能够禁止volatile变量写操作与该操作之前的任何读、写操作进行重排序，因此用volatile修饰theFlooble相当于禁止JIT编译器与处理器将子操作②(对对象进行初始化的写操作)重排序到子操作③(将对象的引用写入共享变量的写操作)，这保证了一个线程(线程B)读取到theFlooble变量所引用的实例时该实例已经初始化完毕。</li></ul><p>对于安全发布还有一个典型的例子就是双重检查锁定(Double-checked Locking，DCL)的单例模式。volatile保证了以下示例中的操作③与操作①不被重排序，具体分析同上面的安全发布。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 保存该类的唯一实例 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLSingleton instance;</span><br><span class="line">    <span class="comment">/* 私有构造器 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并返回该类的唯一实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 操作①</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DCLSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 操作② </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> DCLSingleton(); <span class="comment">// 操作③</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>对final域的读和写更像是对普通变量的访问。 对于final域，编译器和处理器要遵守两个重排序规则：</p><ul><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ul><p><strong>写final域的重排序规则</strong><br>写final域的重排序规则禁止把final域的写重排序到构造函数之外。JMM规定：<em>JMM禁止编译器把final域的写重排序到构造函数之外</em>。编译器的具体实现：编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。<br><strong>读final域的排序规则</strong><br>在一个线程中，初次读对象引用与初次读对象包含的final域，JMM规定：JMM禁止处理器重排序这两个操作(这里仅仅指处理器)，编译器会在读final域前插入一个LoadLoad屏障。</p><p>要达成写final域的重排序规则，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，我们看下面的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalVariableEscape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FinalVariableEscape obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalVariableEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 操作①</span></span><br><span class="line">        obj = <span class="keyword">this</span>; <span class="comment">// 操作②</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalVariableEscape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj != <span class="keyword">null</span> : obj.i ? <span class="number">0</span>; <span class="comment">// 操作③</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个线程A执行writer()方法，另一个线程B执行 reader()方法。这里的操作②使得对象还未完成构造前就为线程B可见。即使这里的操作②是构造函数的最后一步，且即使在程序中操作② 排在操作①后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作①和操作②之间可能被重排序。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a><br>[2] <a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a><br>[3] <a href="https://www.infoq.cn/article/java_memory_model">深入理解Java内存模型</a><br>[4] <a href="https://www.ibm.com/developerworks/java/library/j-jtp06197/index.html">Managing volatility</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java在并发并发编程中，实现各个线程之间的安全可靠通信中，volatile、synchronized与final这三个原语起到了关键作用。可以说是Java在语言层面实现并发编程线程安全的基石。其中volatile与final更是基础中的基础，本文记录笔者在学习关于这部分一些整理。&lt;/p&gt;
&lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;p&gt;Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当声明共享变量为volatile变量时，对这个变量的读、写将会变得很特别。特别之处主要体现在两个方面：其自身特性与其对内存可见性的影响。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>缓存一致性</title>
    <link href="https://techcoffe.com/2019/05/07/Cache-Consistency/"/>
    <id>https://techcoffe.com/2019/05/07/Cache-Consistency/</id>
    <published>2019-05-07T14:47:15.000Z</published>
    <updated>2020-08-22T03:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对最近学习Java内存模型有关的内容进行的总结，该部分只包括处理器层缓存一致性相关的内容。这部分内容是更好的理解Java内存模型的前提。关于Java语言层内存模型相关的内容放到下一篇文章记录整理。</p><h2 id="处理器系统组织方式"><a href="#处理器系统组织方式" class="headerlink" title="处理器系统组织方式"></a>处理器系统组织方式</h2><p>多处理器系统存在多种组织方式，可以分为共享存储结构和非共享存储结构。对系统内存进行统一编址，进程可以直接访问本地节点和其他节点主存中的数据。非共享存储结构也可以共享主存，但是对于非本地节点的主存不能直接访问，需通过软件辅助间接访问，时间开销较大。共享存储的多处理器系统还可以分为集中式共享存储结构和分布式共享存储结构。其中集中式共享存储结构又称为均匀访存延迟的存储结构(UMA)，又可分为并行向量处理机(PVP)和对称多处理器系统(SMP)。分布式共享存储结构包括非均匀访存延迟的存储结构(NUMA)和无远程访问结构(NORMA)。下图对以上分类进行了总结：</p><a id="more"></a><img src="/img/2019/5/多处理器系统组成分类.png" alt="图1-多处理器系统组成分类" width="80%"><h2 id="处理器存储结构"><a href="#处理器存储结构" class="headerlink" title="处理器存储结构"></a>处理器存储结构</h2><p>我们知道计算机在程序执行时，每一条指令都在CPU中执行，执行时需要的数据需要从系统内存中获取。但是随着技术的不断演进，人们发现存储器的读写速度与处理器的指令执行速度差距越来越大，这就导致CPU每次执行内存相关的操作都要耗费很长的时间。经过不断的摸索，人们想出了一个好办法，就是在处理器和内存之间插入高速缓存。当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。随着处理器处理速度的不断提高，逐步出现了一级缓存、二级缓存与三级缓存。下图是多核多处理器的缓存结构示意图:<br><img src="/img/2019/5/多核处理器缓存结构.png" alt="图2-多核处理器缓存结构" width="80%"><br>有了多级缓存之后，程序执行时当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</p><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>引入缓存解决了处理器执行速度与内存读写速度的执行瓶颈的问题，但缓存的引入同时也带来了新的问题：<em>缓存一致性</em>。在共享存储的多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存或三级缓存。当多个线程并发访问同一个共享变量的时候，这些线程的执行处理器上的高速缓存各自都会保留一份改共享变量的副本，一个处理器对其副本数据进行更新之后，其它处理器如何“觉察”到该更新并做出适当反应，以确保这些处理器后续读取该共享变量时能够读取到这个更新。这就是上面提到的缓存一致性问题，其实质就是如何防止读脏数据和丢失更新的问题。<br>维护一致性有<strong>写直达WT（Write Through）</strong>和<strong>写回WB（Write Back）</strong>两种高速缓存：写直达高速缓存采用的策略是一旦高速缓存中的一个字被修改过，则在主存中要立即修改；而写回高速缓存的策略是对高速缓存的修改延迟到被修改的字从高速缓存中被替换或消除时，才真正修改主存。<br>具体示例如图3所示，图3显示三个带有私有高速缓存的处理器，其高速缓存通过总线与共享主存相连。考虑主存中的一个位置u和以下的一系列处理器发出的访问u的指令：首先，P1从主存中读u，从而P1的高速缓存中建立了一个u的拷贝；然后，P3从主存中读u，从而在P3的高速缓存中也建立了一个u的拷贝；接着，P3向主存写u，将u值从5改写为7。下面我们根据高速缓存类型分情况讨论：</p><ul><li>采用写直达高速缓存：<blockquote><p>P3写u时，将直接更新主存，然后当P1再一次读u时（动作 4），将读到无效值5，而不是主存中的当前值7；</p></blockquote></li><li>采用写回高速缓存：<blockquote><p>P3写u时，标记为脏（dirty），暂时把修改过的（脏的）值放在自己的高速缓存中，并不直接更新主存。只有当u所在的块被从高速缓存中替换出去时，才将其值写回主存。这样一来，不仅P1再次读时将读到旧值，而且P2读u（动作5）时，也从主存读到旧值5，而不是新值7。最后，如果多个处理器对在写回高速缓存中的u写了一系列值，则最终主存中是哪个值，将取决于u所在高速缓存块被替换的次序，而与对u的写操作的发生次序无关。</p></blockquote></li></ul><img src="/img/2019/5/缓存一致性读写示例.png" alt="图3-缓存一致性读写示例" width="80%"><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>为了解决缓存不一致的这类问题，处理器之间需要一种约束(通信机制)——*缓存一致性协议(Cache Coherence Protocol)*。高速缓存一致性协议中广泛采用的有两类协议——基于目录的协议和基于侦听的协议。</p><ul><li>基于目录的协议<blockquote><p>对于共享存储其中的数据块设置目录项来跟踪、记录其状态信息，从而知道哪些节点应该对请求做出何种操作。目录协议的实现方案较多，根据目录存储方法的不同可以分为集中式目录协议(如Tang)、分布式目录协议(如Censiert)等。</p></blockquote></li><li>基于侦听的协议<blockquote><p>另一种多核处理器中维护高速缓存一致性的常用方法。具体来说，缓存控制器通过共享总线事务来更新本地数据的一致性状态。这里，高速缓存一致性的维护可以看作是一组有限状态机的状态变迁。挂接在总线上的节点接收到一致性请求后，会根据消息类型和自身状态，更新数据状态并向请求者做出响应。避免出现缓存内容不一致的方案有两种，分别为“写作废”与“写更新”。“写作废”是将所有远程拥有相同数据块副本的缓存中对应内容“作废”，使有效数据只有一个，典型的协议有MSI协议和MESI协议等；“写更新”是将存有相同数据块副本的缓存中对应内容“更新”，可能出现多个有效数据。典型的协议有Dragon等。不过，“写更新”方案需要将更新内容发送到所有须更新的缓存中，会大大增加总线的负担，一般使用得不多。</p></blockquote></li></ul><p>在侦听协议设计中，主要有两种设计选择：①是写直达高速缓存，还是写回高速缓存；②是写无效WI（Write-Invalidate），还是写更新WU（Write-Update）协议。以下我们讨论一下这两种设计选择。<br>我们将对写直达和写回分别进行分析：在写直达方式下，主存总是与高速缓存中的最新值保持一致，但这种方式在每次高速缓存的写操作后，都需要更新主存从而需要额外的总线周期；在写回方式下，主存的更新要到发生替换时才进行，因此在高速缓存的写操作命中后的瞬间，高速缓存和主存是不一致的。写回实际上尽量延迟写直达中对主存的更新，因此它只需占有较少的总线周期，故在存储器总线结构上采用写回高速缓存更经济。<br>另一个主要的选择是采用写无效还是写更新协议：写无效协议在本地高速缓存中数据被更新后，使所有其他高速缓存中的相应数据拷贝无效，接下来由同一个处理器发出的对该内存块的写操作就不会在总线上引起任何通信；写更新协议则广播修改后的数据，以更新所有的高速缓存中的相应数据拷贝，因此当拥有该块拷贝的处理器接下来存取这个新数据时，存取延迟就很小。另外，由于一个总线事务就能更新所有拥有该块的高速缓存中内容，因此如果该块有多个共享者，则能极大节约总线带宽。<br>具体分类如图4所示。<br><img src="/img/2019/5/缓存一致性协议分类.png" alt="图4-缓存一致性协议分类" width="80%"><br>基于侦听的缓存一致性协议主要有MSI协议、MESI协议、MESIF协议、MOESI协议，其中MESIF协议与MOESI协议分别是Intel Core i7处理器与AMD Opteron处理器对MESI协议的优化。下面重点介绍经典的缓存一致性协议——MESI协议。</p><h2 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h2><p>单核Cache中每个Cache line有2个标志：dirty和valid标志，它们很好的描述了Cache和Memory(内存)之间的数据关系(数据是否有效，数据是否被修改)，而在多核处理器中，多个核会共享一些数据，MESI协议就包含了描述共享的状态。为了保障数据的一致性，MESI协议将缓存条目的状态划分为Modified、Exclusive、Shared和Invalid4种，并在此基础上定义了一组消息用于协调各个处理器的读写请求。MESI协议中四个状态具体含义如下:</p><ul><li>Invalid(无效的，记为I)：该状态表示相应缓存行中不包含任何内存地址对应的有效副本数据。该状态是缓存条目的初始数据。</li><li>Shared(共享的，记为S)：该状态表示相应缓存行包含相应内存地址所对应的副本数据。并且，其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据。因此，一个缓存条目的状态如果为Shared，并且其他处理器上也存在Tag值与该缓存条目的Tag值相同的缓存条目，那么这些缓存条目的状态也为Shared。<em>处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。</em></li><li>Exclusive(独占的，记为E)：该状态表示相应缓存行包含相应内存地址所对应的副本数据。并且该缓存行以独占的方式保留了相应内存地址的副本数据，即其它所有处理器上的高速缓存当前都不保留该数据的有效副本。<em>处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。</em></li><li>Modified(更改过的，记为M)：该状态表示相应的缓存行包含对相应内存地址所做的更新。由于MESI协议中任意一个时刻只能有一个处理器对同一内存地址对应的数据进行更新，因此在多个处理器上的高速缓存中Tag值相同的缓存条目中，任意一个时刻只能有一个缓存条目处于该状态。<em>处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据不一致。</em></li></ul><p>MESI协议各个状态之间的转换关系如图5所示，详细的转换过程不再描述，可以参考相应的资料，如《Java多线程编程实战指南-核心篇》。<br><img src="/img/2019/5/MESI协议状态机.png" alt="图5-MESI协议状态机" width="80%"></p><h2 id="硬件缓冲区：写缓冲器与无效化队列"><a href="#硬件缓冲区：写缓冲器与无效化队列" class="headerlink" title="硬件缓冲区：写缓冲器与无效化队列"></a>硬件缓冲区：写缓冲器与无效化队列</h2><p>MESI协议解决了缓存一致性问题，但是其自身也存在一个性能弱点：处理器执行写内存操作时，必须等待其他所有处理器将其高速缓存中的相应副本数据删除并接收到这些处理器回复的Invalidate Acknowledge/Read Response消息之后才能将数据写入高速缓存。为了规避和减少这种等待造成的写操作的延迟，硬件设计者引入了写缓冲器与无效化队列。</p><ul><li>写缓冲器：是处理器内部的私有高速存储部件，每个处理器都有其写缓冲器，写缓冲器内部可包含若干条目。一个处理器无法读取其他处理器上写缓冲器中的内容。</li><li>无效化队列：处理器在接收到Invalidate消息之后并不删除消息中指定地址对应的副本数据，而是将消息存入无效化队列之后就回复Acknowledge消息，从而减少了写操作执行处理器所需的等待时间。是否存在无效化队列视各个处理器的设计。</li></ul><p>引入写缓冲器与无效化队列后的处理器结构如图6所示。<br><img src="/img/2019/5/写缓冲器与无效化队列.png" alt="图6-写缓冲器与无效化队列" width="50%"></p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>引入写缓冲器与无效化队列后带了一些新的问题：内存重排序与可见性问题。为了解决重此类问题便引入了内存屏障指令。内存屏障分为两类：</p><ul><li>存储屏障：写线程的执行处理器所执行的存储屏障保障了该线程对共享变量所做的更新对读线程来说是同步的(冲刷处理器缓存)；</li><li>加载屏障：读线程的执行处理器所执行的加载屏障将写线程对共享变量所做的更新同步到该处理器的高速缓存之中(刷新处理器缓存)。<br>主要包括：LoadLoad屏障、LoadStore屏障、StoreStore屏障和StoreLoad屏障。</li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>[1] <a href="https://os.inf.tu-dresden.de/Studium/DOS/SS2011/02-Coherency.pdf">Advanced Systems Programming: Quick Poll</a><br>[2] <a href="https://www.hollischuang.com/archives/2550">再有人问你Java内存模型是什么，就把这篇文章发给他</a><br>[3] 周君，唐士斌，商用多核处理器中的存储器一致性模型与高速缓存同一性协议。信息技术快报，Vol.11 No.1<br>[3] <a href="https://book.douban.com/subject/27034721/">Java多线程编程实战指南-核心篇</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对最近学习Java内存模型有关的内容进行的总结，该部分只包括处理器层缓存一致性相关的内容。这部分内容是更好的理解Java内存模型的前提。关于Java语言层内存模型相关的内容放到下一篇文章记录整理。&lt;/p&gt;
&lt;h2 id=&quot;处理器系统组织方式&quot;&gt;&lt;a href=&quot;#处理器系统组织方式&quot; class=&quot;headerlink&quot; title=&quot;处理器系统组织方式&quot;&gt;&lt;/a&gt;处理器系统组织方式&lt;/h2&gt;&lt;p&gt;多处理器系统存在多种组织方式，可以分为共享存储结构和非共享存储结构。对系统内存进行统一编址，进程可以直接访问本地节点和其他节点主存中的数据。非共享存储结构也可以共享主存，但是对于非本地节点的主存不能直接访问，需通过软件辅助间接访问，时间开销较大。共享存储的多处理器系统还可以分为集中式共享存储结构和分布式共享存储结构。其中集中式共享存储结构又称为均匀访存延迟的存储结构(UMA)，又可分为并行向量处理机(PVP)和对称多处理器系统(SMP)。分布式共享存储结构包括非均匀访存延迟的存储结构(NUMA)和无远程访问结构(NORMA)。下图对以上分类进行了总结：&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发编程实战笔记</title>
    <link href="https://techcoffe.com/2019/04/30/Notes-of-Java-Concurrency-in-Practice/"/>
    <id>https://techcoffe.com/2019/04/30/Notes-of-Java-Concurrency-in-Practice/</id>
    <published>2019-04-30T00:54:09.000Z</published>
    <updated>2020-08-22T03:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-线程安全性"><a href="#1-线程安全性" class="headerlink" title="1. 线程安全性"></a>1. 线程安全性</h2><ul><li><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li></ul><p>线程安全性：当多个线程访问某个类时，这个类始终能表现出正确的行为，那么就称这个类是线程安全的。</p><blockquote><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p></blockquote><ul><li><h3 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h3></li></ul><p>在第二章讲线程安全性中关于锁重入有这样一个示例(2.3.2):</p><blockquote><p>子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。由于Widget和LoggingWidget中doSomething方法都是synchronized方法，<em>因此每个doSomething方法在执行前都会获取Widget上的锁。</em>因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远无法获取的锁。重入则避免了这种情况的发生。</p></blockquote><a id="more"></a><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> doSomthing &#123;</span><br><span class="line">        System.out.println(toString + <span class="string">&quot;: calling doSomthing&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomthing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里作者的表述或者翻译不够严禁，正确的表述如下：</p><blockquote><p>子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。由于Widget和LoggingWidget中doSomething方法都是synchronized方法，<em>因此每个doSomething方法在执行前都会获得调用该方法当前实例上的锁。</em></p></blockquote><ul><li>当线程执行LoggingWidget实例中的doSomething时获得LoggingWidget实例的锁。</li><li>LoggingWidget实例doSomething方法中调用super.doSomething()，调用者依然是LoggingWidget实例，再次获得的锁依然是LoggingWidget实例的锁。</li><li>线程再次获得LoggingWidget实例的锁，即锁的重入。</li></ul><p>总之，理解这个问题的重点： <strong>锁的持有者是线程，锁是加在当前实例。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作者：知乎用户</span><br><span class="line">链接：https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;28113814&#x2F;answer&#x2F;126229336</span><br><span class="line">来源：知乎</span><br></pre></td></tr></table></figure><h2 id="2-一种加锁分析方法"><a href="#2-一种加锁分析方法" class="headerlink" title="2. 一种加锁分析方法"></a>2. 一种加锁分析方法</h2><p>最近在极客时间中看到一种以图例方式表示资源与其对应锁之间关系的方法，在分析锁相关的问题时还是比较直观的。具体实现方式如下图：<br><img src="/img/2019/7/加锁模型.png" alt="图1-加锁模型" width="40%"></p><ul><li>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素:受保护的资源R;</li><li>其次，我们要保护资源R就得为它创建一把锁LR;</li><li>最后，针对这把锁LR，我们还需在进出临界区时添上加锁操作和解锁操作。</li></ul><p>另外，在锁LR和受保护资源之间，用一条线做了关联，这个关联关系非常重要。很多并发Bug的出现都是因为把它忽略了,然后就出现了类似锁自家门来保护他家资产的事情,这样的Bug非常不好诊断，因为潜意识里我们认为已经正确加锁了。</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-线程安全性&quot;&gt;&lt;a href=&quot;#1-线程安全性&quot; class=&quot;headerlink&quot; title=&quot;1. 线程安全性&quot;&gt;&lt;/a&gt;1. 线程安全性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程安全性：当多个线程访问某个类时，这个类始终能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;锁重入&quot;&gt;&lt;a href=&quot;#锁重入&quot; class=&quot;headerlink&quot; title=&quot;锁重入&quot;&gt;&lt;/a&gt;锁重入&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在第二章讲线程安全性中关于锁重入有这样一个示例(2.3.2):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。由于Widget和LoggingWidget中doSomething方法都是synchronized方法，&lt;em&gt;因此每个doSomething方法在执行前都会获取Widget上的锁。&lt;/em&gt;因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远无法获取的锁。重入则避免了这种情况的发生。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8特性-Lambda表达式</title>
    <link href="https://techcoffe.com/2019/03/03/Characteristic-of-Java8-Lambda/"/>
    <id>https://techcoffe.com/2019/03/03/Characteristic-of-Java8-Lambda/</id>
    <published>2019-03-03T01:15:32.000Z</published>
    <updated>2020-08-22T03:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul><li>行为参数化</li><li>函数式编程</li><li>流处理</li></ul><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><ul><li>没有共享的可变数据，将方法和函数即代码传递给其他方法的能力是函数式编程范式的基石。</li><li>编写把函数作为一等值传递的程序。</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>为什么叫Lambda表达式(为什么用字母λ)：源于计算机科学家Alonzo Church，后来带参数变量的表达式就称为Lambda表达式。<br>理论上来说，你在Java 8之前做不了的事情，Lambda也做不了。但是，现在你用不着再用匿名类写一堆笨重的代码。Lambda表达式本身的类型：函数式接口。</p><a id="more"></a><p><strong>函数式接口</strong>：只定义一个抽象方法的接口，用作Lambda表达式的类型。</p><blockquote><p>这里注意强调的是抽象方法，并不包括static、default方法</p></blockquote><h3 id="Lambda表达式形式"><a href="#Lambda表达式形式" class="headerlink" title="Lambda表达式形式"></a>Lambda表达式形式</h3><ul><li>(parameters) -&gt; expression</li><li>(parameters) -&gt; { statements; }</li></ul><blockquote><ul><li><strong><em>Lambda表达转换的关键点：抽象方法的签名要与Lambda表达式的签名相对应。</em></strong><br>举例：(T,U) -&gt; R的表达方式展示了应当如何思考一个函数描述符。这里它代表一个函数，具有两个参数，分别为泛型入参 T和U，返回类型为R。</li><li>如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必须与之匹配。</li><li>如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// ① Predicate返回了一个boolean</span></span><br><span class="line">Predicate&lt;String&gt; a = s -&gt; list.add(s);</span><br><span class="line"><span class="comment">// ② Consumer返回了一个void</span></span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句①与语句②分别等价于以下语句③与④，且下面的语句更容易理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句③ Predicate返回了一个boolean</span></span><br><span class="line">Predicate&lt;String&gt; c = s -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.add(s);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 语句④ Consumer返回了一个void，函数体中只有表达式没有返回值</span></span><br><span class="line">Consumer&lt;String&gt; d = s -&gt; &#123;</span><br><span class="line">    list.add(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><ul><li>Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如，接受它传递的方法的参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型。</li><li>同一个Lambda表达式可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; c = () -&gt; <span class="number">42</span>; </span><br><span class="line">PrivilegedAction&lt;Integer&gt; p = () -&gt; <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li><li>如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Predicate返回了一个boolean</span></span><br><span class="line">Predicate&lt;String&gt; p = s -&gt; list.add(s);</span><br><span class="line"><span class="comment">// Consumer返回了一个void</span></span><br><span class="line">Consumer&lt;String&gt; b = s -&gt; list.add(s);</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><ul><li>Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。<blockquote><p>注：捕获实例变量可以被看作捕获最终局部变量this。</p></blockquote></li><li>局部变量必须显式声明为final，或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。<blockquote><p><strong>对局部变量访问限制的原因</strong></p><ul><li>第一，实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线 程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li><li>第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式(这种模式会阻碍很容易做到的并行处理)。</li></ul></blockquote></li></ul><h3 id="Lambda表达式与闭包"><a href="#Lambda表达式与闭包" class="headerlink" title="Lambda表达式与闭包"></a>Lambda表达式与闭包</h3><p>闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。现在，Java8的Lambda和匿名类可以做类似于闭包的事情：**<em>它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。这些变量必须是final，或事实上是final的。**</em>可以认为Lambda是对值封闭，而不是对变量封闭。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。**<em>你可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖，因为你表达同样的事情 时要写的代码更少了。**</em></p><ul><li>指向静态方法的引用<img src="/img/2019/4/method_refer1.png" width="50%"></li><li>指向任意类型实例方法的方法引用<img src="/img/2019/4/method_refer2.png" width="50%"></li><li>指向现有对象的实例方法的方法引用<img src="/img/2019/4/method_refer3.png" width="50%"></li><li>构造函数引用<ul><li>实例构造器：Class::new<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, Integer, Apple&gt; c = Apple::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">BiFunction&lt;String, Integer, Apple&gt; c = (color, weight) -&gt; <span class="keyword">new</span> Apple(color, weight);</span><br></pre></td></tr></table></figure></li><li>数据构造器：int[]::new，等价于lambda表达式(int x) -&gt; new int[x]</li></ul></li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>[1] Java8实战<br>[2] Java核心技术卷一(第10版)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;行为参数化&lt;/li&gt;
&lt;li&gt;函数式编程&lt;/li&gt;
&lt;li&gt;流处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是函数式编程&quot;&gt;&lt;/a&gt;什么是函数式编程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;没有共享的可变数据，将方法和函数即代码传递给其他方法的能力是函数式编程范式的基石。&lt;/li&gt;
&lt;li&gt;编写把函数作为一等值传递的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;p&gt;为什么叫Lambda表达式(为什么用字母λ)：源于计算机科学家Alonzo Church，后来带参数变量的表达式就称为Lambda表达式。&lt;br&gt;理论上来说，你在Java 8之前做不了的事情，Lambda也做不了。但是，现在你用不着再用匿名类写一堆笨重的代码。Lambda表达式本身的类型：函数式接口。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="https://techcoffe.com/2019/03/03/Java-Generic/"/>
    <id>https://techcoffe.com/2019/03/03/Java-Generic/</id>
    <published>2019-03-03T00:09:02.000Z</published>
    <updated>2020-08-22T03:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>Java 1.5发行版中增加了泛型(Generic)。在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转换，并在编译时告知是否插入了类型错误的对象。这样可以使程序既更加安全，也更加清楚。为了更清楚的说明以上表述，我们通过例子来看下，引入泛型前后的对比：</p><ul><li>避免了类型转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①引入泛型之前需要对读取的内容进行类型转换</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s = (String) list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②引入泛型之后不需要进行类型转换</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s = list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure></li><li>错误检查前置到编译阶段<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ①使用泛型</span></span><br><span class="line">        Comparable&lt;Date&gt; c1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(c1.compareTo(<span class="string">&quot;red&quot;</span>)); <span class="comment">//编译错误</span></span><br><span class="line">        <span class="comment">// ②未使用泛型</span></span><br><span class="line">        Comparable c2 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(c2.compareTo(<span class="string">&quot;red&quot;</span>)); <span class="comment">//运行时错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a></li></ul><h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>同在方法声明中的常规参数一样，类型参数提供了针对不同输入对同一代码重用的方式。不同在于对于常规参数的输入是数值，而对于类型参数输入的是类型。类型参数的命名约定：类型参数名是单个的大写的字母。常用的类型参数名，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E - Element (used extensively by the Java Collections Framework)</span><br><span class="line">K - Key</span><br><span class="line">N - Number</span><br><span class="line">T - Type</span><br><span class="line">V - Value</span><br><span class="line">S,U,V etc. - 2nd, 3rd, 4th types</span><br></pre></td></tr></table></figure><p>Type Parameter and Type Argument Terminology</p><blockquote><p>Type Parameter and Type Argument Terminology: Many developers use the terms “type parameter” and “type argument” interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the T in Foo<T> is a type parameter and the String in Foo<String> f is a type argument.</p></blockquote><h2 id="泛型类与泛型接口"><a href="#泛型类与泛型接口" class="headerlink" title="泛型类与泛型接口"></a>泛型类与泛型接口</h2><p>一个泛型类就是具有一个或多个类型变量的类。类定义中的类型参数用于指定方法的返回类型以及域和局部变量的类型。泛型类定义时只需要在类名后面加上类型参数即可。泛型类举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key; </span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key; </span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> key; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口与与泛型类的定义类似，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口与扩展泛型类要注意以下两点：</p><ul><li>泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。继承泛型类，也是一样。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 即：class FruitGenerator implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。继承泛型类，也是一样。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataHolder</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>我们经常会遇到这种情况，需要指定泛型类型，但希望控制可以指定的类型，而非不加限制。比如计算数组中最小元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">min</span><span class="params">(R[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        R minValue = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].compareTo(minValue) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                minValue = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何保证数组中每一个元素与变量minValue所属的类R有CompareTo方法呢？解决这类问题就是通过类型变量的限定实现，即将T限制为实现了Comparable接口的类。即：<code>public static &lt;R extends Comparable&lt;R&gt;&gt; R min(R[] a)</code>。<br><strong>类型变量限定的用法：</strong> <code>&lt;T extends BoundingType&gt;</code></p><blockquote><p>表示T应该是绑定类型的子类型(subtype)，T和绑定类型可以是类也可以是接口。选择关键字extends的原因是更接近子类的概念并且Java的设计者也不打算在语言中再添加一个新的关键字(如sub)。</p></blockquote><p>通过类型变量限制的计算数组最小元素的方法改动如下，这样我们就保证了R一定是实现了Comparable接口的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有直接使用public static &lt;R extends Comparable&lt;R&gt;&gt; R min(R[] a)定义</span></span><br><span class="line">    <span class="comment">// 是因为R在某些指定类型下不兼容，比如LocalDate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R extends Comparable&lt;? <span class="keyword">super</span> R&gt;&gt; <span class="function">R <span class="title">min</span><span class="params">(R[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        R minValue = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].compareTo(minValue) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                minValue = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类型变量或通配符可以有多个限定，例如：T extends Comparable&amp;Serializable。在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类，作为限定它必须是限定列表中的第一个。</p><h2 id="原始类型-Raw-Type"><a href="#原始类型-Raw-Type" class="headerlink" title="原始类型(Raw Type)"></a>原始类型(Raw Type)</h2><p>未分配类型的泛型称为原始类型(Raw Type)，即没有任何类型实参的泛型类和泛型接口。Raw Type举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类Box定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Raw type：不带实际类型参数(Box&lt;T&gt;的Raw Type)</span></span><br><span class="line">Box rawBox = <span class="keyword">new</span> Box();</span><br></pre></td></tr></table></figure><ul><li>如果T是无限定变量，那么T用Object来替换。</li><li>如果T是限定变量，那么T用第一个限定类型变量来替换。</li></ul><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul><li>带有一个或多个类型参数的方法</li><li>方法参数可以包含泛型类型，方法也可以包含泛型返回类型。</li><li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li><li><em>只有在方法返回值之前，方法修饰符之后存在泛型参数列，这样的方法才是泛型方法。这则条件隐含着该方法要么入参包含泛型类型，要么返回值包含泛型类型。</em></li></ul><p><strong>泛型方法Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法调用"><a href="#泛型方法调用" class="headerlink" title="泛型方法调用"></a>泛型方法调用</h3><ul><li>标准<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">2</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br></pre></td></tr></table></figure></li><li>基于类型推断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">2</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> same = Util.compare(p1, p2);</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型方法注意点"><a href="#泛型方法注意点" class="headerlink" title="泛型方法注意点"></a>泛型方法注意点</h3><ul><li>泛型类中定义的带有带有泛型参数的普通方法并不是泛型方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虽然方法1与方法2均使用了泛型，但并不是泛型方法，他们只是类中的普通成员方法。</span></span><br><span class="line"><span class="comment">     * 只不过他的返回值或者入参是在声明泛型类已经声明过的泛型，所以在方法中才可以使用T这个泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于一个static方法而言，无法访问泛型类的类型参数，如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。即，如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenericMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void fun(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">     * &quot;StaticGenericMethod cannot be refrenced from static context&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>泛型类中的泛型方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line"><span class="comment">     * 由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中的泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一回事。</span></span><br><span class="line"><span class="comment">     * 但是在平时写代码时不要这样写，因为会带来很大的疑惑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><ul><li>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界。</li><li>泛型擦除的动机是它使得泛型的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”。</li></ul><h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><h3 id="对泛型类继承规则的误解"><a href="#对泛型类继承规则的误解" class="headerlink" title="对泛型类继承规则的误解"></a>对泛型类继承规则的误解</h3><p>在Java语言中变量是多态的，即子类的每个对象也是超类的对象，用面向对象的术语，这就是“is-a”规则。比如，可将一个Integer对象赋值给Number对象，因为Number是Integer的超类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number obj1 = <span class="keyword">new</span> Number();</span><br><span class="line">Integer obj2 = <span class="keyword">new</span> Integer();</span><br><span class="line">obj1 = obj2; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>这一规则对于泛型类型变量的赋值同样适用。下面通过一个例子来进行说明。定义一个Box<T>泛型类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;T=&quot;</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Number&gt; box = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        box.display(<span class="number">10</span>); <span class="comment">// OK</span></span><br><span class="line">        box.display(<span class="number">10.5</span>); <span class="comment">// OK</span></span><br><span class="line">        box.display(<span class="keyword">new</span> Apple()) <span class="comment">// compile error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>它的入参接受一个什么样的类型呢？通过该方法签名可以知道，boxTest方法接受一个类型为<code>Box&lt;Number&gt;</code>的一个变量。但这是代表什么意思呢？可以将<code>Box&lt;Integer&gt;</code>或者<code>Box&lt;Double&gt;</code>赋值给他吗？答案是否定的！因为<code>Box&lt;Integer&gt;</code>与<code>Box&lt;Double&gt;</code>不是<code>Box&lt;Integer&gt;</code>的子类型，更确切的说，<code>Box&lt;Ingeger&gt;</code>或<code>Box&lt;Double&gt;</code>与<code>Box&lt;Number&gt;</code>没有任何关系，<code>Box&lt;Integer&gt;</code>与<code>Box&lt;Double&gt;</code>也没有什么关系。<br>即：<em>给定两个具体类型A和B(比如Number和Integer)，<code>MyClass&lt;A&gt;</code>与<code>MyClass&lt;B&gt;</code>没有任何关系，无论A与B是否相关。</em><br>以上关系可以通过图1表示。<br><img src="/img/2019/10/泛型继承关系1.png" alt="图1-泛型继承关系" width="60%"></p><h3 id="泛型类与子类型"><a href="#泛型类与子类型" class="headerlink" title="泛型类与子类型"></a>泛型类与子类型</h3><p>与普通类一样，泛型类可以扩展或实现其它的泛型类，通过extends或implements关键字。例如，<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，这就意味着<code>ArrayList&lt;Integer&gt;</code>可以被转换为一个<code>List&lt;Integer&gt;</code>，但如前所述，<code>ArrayList&lt;Integer&gt;</code>不是一个<code>ArrayList&lt;Number&gt;</code>，也不是一个<code>List&lt;Number&gt;</code>。图2展示了它们之间的关系。<br><img src="/img/2019/10/泛型继承关系2.png" alt="图2-泛型继承关系" width="60%"></p><p>对于有多个类型变量的泛型类的继承关系又是什么样的呢？设想我们有如下的泛型接口PaloadList，该接口扩展自List接口，并且新增一个类型参数P。接口声明可能的形式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PayloadList</span>&lt;<span class="title">E</span>,<span class="title">P</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPayload</span><span class="params">(<span class="keyword">int</span> index, P val)</span></span>;</span><br><span class="line">    <span class="comment">// 省略其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么以下PayloadList的参数化类型均是List<String>的子类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PayloadList&lt;String,String&gt;</span><br><span class="line">PayloadList&lt;String,Integer&gt;</span><br><span class="line">PayloadList&lt;String,Exception&gt;</span><br></pre></td></tr></table></figure><p>PayloadList的继承关系如图3所示。<br><img src="/img/2019/10/泛型继承关系3.png" alt="图3-泛型继承关系" width="60%"></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>某些情况下，编写指定未知类型的代码很有用。在Java泛型中使用问号(?)，来表示一个不确定的类型。这一标记叫做通配符。通配符可用于参数、字段、局部变量和返回类型。但最好不要在返回类型中使用通配符，因为确切知道方法返回的类型更安全。在使用通配符的时候要注意，使用通配符的使用一定不要同泛型的定义搞混，通配符是在泛型定义完成之后，在使用该泛型类、泛型接口与泛型方法时对其类型参数进行约束的。这句话如何理解呢？举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 定义一个未使用通配符的方法</span></span><br><span class="line"><span class="comment">// 说明：该方法只能接受List&lt;Foo&gt;型的变量，方法的使用受到极大的限制，Java的多态也不能得到应用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Foo&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Foo elem : list) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② 定义一个使用统配符的方法</span></span><br><span class="line"><span class="comment">// 说明：与①定义的方法不同，该方法接受Foo及Foo的子类，Foo的方法都可以调用，体现了Java多态的优势。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;? extends Foo&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Foo elem : list) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通配符主要分为三种上界通配符、下界通配符与无界通配符。</p><h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p><strong>定义:</strong> 上界统配符使用通配符(?)，后面跟着extends关键字，最后是它的上界。<em>注意：extends同类的继承不同，上界通配符的extends后面的上界既可以是类，也可以是接口。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中Foo是任意是任意的类或接口</span></span><br><span class="line">&lt;? extends Foo&gt;</span><br></pre></td></tr></table></figure><p>上界通配符的含义是容器中存放是Foo或Foo的子类，但具体是哪一个具体的类型我不知道。<em>正因为有这样的含义，导致上界统配符在使用的时候，只能从容器中读，但是不能向容器里面写。</em>假设有下面的类继承关系:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个类层次中，<code>Plate&lt;? extend Fruit&gt;</code>覆盖下面的蓝色部分：<br><img src="/img/2019/10/上界通配符.png" alt="图4-上界通配符" width="60%"></p><h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><strong>定义：</strong>下界通配符使用通配符(?)，后面跟着super关键字，最后是它的下界。<em>同样需要注意：下界通配符的super后面的下界既可以是类，也可以是接口。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中Foo是任意是任意的类或接口</span></span><br><span class="line">&lt;? <span class="keyword">super</span> Foo&gt;</span><br></pre></td></tr></table></figure><p>下界通配符的含义是容器中存放的是Foo或Foo的超类，但是具体是哪个一个超类我不知道。<em>下界通配符规定了元素最小的粒度，必须是Foo及其基类，那么我往里面存储Foo及其派生类都是可以的，因为它都可以隐式的转化为Foo类型。但是往外读就不好控制了，里面存储的都是Foo及其基类，无法转型为任何一种类型，只有Object基类才能装下，因此下界通配符只能读取Object。</em><br>下界通配符<code>Plate&lt;? super Fruit&gt;</code>覆盖下面的红色部分:<br><img src="/img/2019/10/下界通配符.png" alt="图5-下界通配符" width="60%"></p><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>有一个古老的段子：</p><blockquote><p>一个人如果他有一只表，那么他可以知道现在是几点。但是如果他有两只表，那么他就不能确切的知道现在到底是几点了。</p></blockquote><p>因为Java语言上界通配符与下界通配符都支持，那么我们应该什么时候使用他们，如何进行选择呢？有一个比较简单的规则，叫做：<em>Get and Put Principle</em>，改规则告诉我们何时，使用哪种通配符。该规则阐述在Naftalin与Wadler合著的《Java Generics and Collections 》一书中。</p><blockquote><p>The Get and Put Principle: use an extends wildcard when you only get values out of a structure, use a super wildcard when you only put values into a structure, and don’t use a wildcard when you both get and put.</p></blockquote><p>PECS表示producer-extends，consumer-super。换句话说，如果参数类型表示一个T生产者，就是用<code>&lt;? extends T&gt;</code>；如果它表示一个T消费者就是用<code>&lt;? super T&gt;</code>。</p><ul><li>上界通配符：只能读，不能写，适合频繁往外面读取内容的场景。</li><li>下界通配符：不影响写，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。</li></ul><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p><strong>定义：</strong>无界通配符使用一个问号进行定义，即<code>&lt;?&gt;</code>。比如<code>List&lt;?&gt;</code>。它表示该容器中存放的是任意的一个类，但具体是哪个一个类不知道。无界通配符的返回值只能付给Object，写入只能是null。无界通配符主要用于以下两个场景：</p><ul><li>场景①：在使用Oject类提供功能实现的方法中。</li></ul><p>考虑下面的方法，printList，该方法的目的是打印任意类型的list。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem : list)</span><br><span class="line">        System.out.println(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但该方法完成不了这一目标，它仅能打印Oject实例的list，不能将该方法应用于<code>List&lt;Integer&gt;、List&lt;Double&gt;</code>等，因为他们同<code>List&lt;Object&gt;</code>没有直接的继承关系。要想达到这一目的，需要使用无界通配符，即<code>List&lt;?&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem: list)</span><br><span class="line">        System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于一个具体类型A，<code>List&lt;A&gt;</code>是<code>List&lt;?&gt;</code>的子类型，因此可用printList方法打印任意类型的list。</p><blockquote><p><em>有点需要注意：<code>List&lt;Object&gt;</code>与<code>List&lt;?&gt;</code>是不同的。可以向<code>List&lt;Object&gt;</code>插入Object对象，或Object任意子类的对象。但只能向<code>List&lt;?&gt;</code>插入null。</em></p></blockquote><ul><li>场景②：在某个使用类型参数的方法中，但该方法不依赖与具体的类型时。<br>考虑下面的例子，在Pair类中判断Pair对象中是否包含对null的引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T etem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getEtem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> etem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEtem</span><span class="params">(T etem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.etem = etem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的hasNull方法虽然对含有类型变量的参数进行处理，</span></span><br><span class="line">    <span class="comment">// 但并不需要知道是具体的什么类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNull</span><span class="params">(Container&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.getEtem() == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通配符与子类型"><a href="#通配符与子类型" class="headerlink" title="通配符与子类型"></a>通配符与子类型</h3><p>类型变量的具体类型与其对应的泛型类或泛型接口没有直接关系，但是通过通配符的引入可以建立泛型类或泛型接口的对应关系。<br>给出如下两个常规的非泛型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>根据Java的赋值规则，下面的赋值关系是合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">A a = b;</span><br></pre></td></tr></table></figure><p>但这一关系并不能应用于泛型类或接口，因为<code>List&lt;A&gt;</code>与<code>List&lt;B&gt;</code>没有直接关系。<code>List&lt;A&gt;</code>与<code>List&lt;B&gt;</code>共同父类是<code>List&lt;?&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;B&gt; lb = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;A&gt; la = lb;   <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure><p>下图展示了上界通配符、下界通配符、无界通配符等修饰的类型直接的继承关系。<br><img src="/img/2019/10/泛型继承关系4.png" alt="图6-泛型继承关系" width="60%"></p><h2 id="泛型约束与局限性"><a href="#泛型约束与局限性" class="headerlink" title="泛型约束与局限性"></a>泛型约束与局限性</h2><ul><li>Cannot Instantiate Generic Types with Primitive Types</li><li>Cannot Create Instances of Type Parameters</li><li>Cannot Declare Static Fields Whose Types are Type Parameters</li><li>Cannot Use Casts or instanceof With Parameterized Types</li><li>Cannot Create Arrays of Parameterized Types</li><li>Cannot Create, Catch, or Throw Objects of Parameterized Types</li><li>Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://blog.csdn.net/s10461/article/details/53941091">java泛型详解</a><br>[2] <a href="https://juejin.im/post/5b614848e51d45355d51f792">深入理解Java泛型</a><br>[3] <a href="https://book.douban.com/subject/26880667/">Java核心技术-卷一</a><br>[4] <a href="https://book.douban.com/subject/2696119/">Effective Java-第二版</a><br>[5] <a href="https://book.douban.com/subject/2130190/">Java编程思想</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;泛型概述&quot;&gt;&lt;a href=&quot;#泛型概述&quot; class=&quot;headerlink&quot; title=&quot;泛型概述&quot;&gt;&lt;/a&gt;泛型概述&lt;/h2&gt;&lt;p&gt;Java 1.5发行版中增加了泛型(Generic)。在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转换，并在编译时告知是否插入了类型错误的对象。这样可以使程序既更加安全，也更加清楚。为了更清楚的说明以上表述，我们通过例子来看下，引入泛型前后的对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了类型转换&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ①引入泛型之前需要对读取的内容进行类型转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String s = (String) list.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ②引入泛型之后不需要进行类型转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String s = list.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;// no cast&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;错误检查前置到编译阶段&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CompareTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ①使用泛型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Comparable&amp;lt;Date&amp;gt; c1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Date();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(c1.compareTo(&lt;span class=&quot;string&quot;&gt;&amp;quot;red&amp;quot;&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;//编译错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ②未使用泛型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Comparable c2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Date();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(c2.compareTo(&lt;span class=&quot;string&quot;&gt;&amp;quot;red&amp;quot;&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;//运行时错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础</title>
    <link href="https://techcoffe.com/2016/04/23/Algorithm-Basic/"/>
    <id>https://techcoffe.com/2016/04/23/Algorithm-Basic/</id>
    <published>2016-04-23T06:31:31.000Z</published>
    <updated>2020-08-22T03:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析算法"><a href="#分析算法" class="headerlink" title="分析算法"></a>分析算法</h2><p>分析算法的结果意味着预测算法需要的资源。虽然我们有时主要关心像内存、通信带宽或计算机硬件这些资源，但通常我们想度量的是计算时间。一般来说，通过分析求解某个问题的几种候选算法，我们可以选出一种最有效的算法。这种分析可能指出不止一个可行的候选算法，但是在这个过程中，我们往往可以抛弃几个较差的算法。一般来说，算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。</p><ul><li>输入规模：输入规模的最佳概念依赖于研究的问题。对于许多问题，最自然的度量是输入中的项数，有时用两个数来描述一个算法的输入规模更为合适，如基于图的算法。</li><li>运行时间：一个算法在特定输入的运行时间是指执行的基本操作数或步数。其中步数，采用以下观点，执行每一行代码需要常量执行时间。<a id="more"></a></li></ul><p>通常用来评判算法性能的三种情况是: 最佳情况、平均情况和最坏情况。任何一种算法的最佳情况的表现都没有太大的差异，分析算法平均情况下的性能往往没有那么容易，甚至我们很难去界定那种情况是平均情况(但某些情况下，我们需要分析平均情况，比如随机算法中的快速排序算法，它使用了概率论的理论基础，从而有效地保证了平均情况下的准确性)，最坏情况可以告诉我们算法性能的上限。分析一个算法的最坏情况可以保证在任何情况下此算法的表现都不会比最坏情况差，而且其他情况一定比最坏的情况要好。</p><h2 id="O表示法"><a href="#O表示法" class="headerlink" title="O表示法"></a>O表示法</h2><p>这是表示算法性能最为常用的方式之一。在一定的条件因素下，O表示法指明一个函数的上限。如果g(n)是f(n)的一个上限值，那么对于常数c，我们总可以找到一个n(称为n0)，当n&gt;=n0是，f(n) &lt;= g(n)。</p><h3 id="O表示法的简单规则"><a href="#O表示法的简单规则" class="headerlink" title="O表示法的简单规则"></a>O表示法的简单规则</h3><ul><li>常数项用O(1)表示</li><li>常量因子往往被忽略</li><li>加法运算取最大值</li><li>乘法结构不需要改变</li></ul><blockquote><p>算法的复杂度O(n)并没有具体表明运行此算法实际需要多少时间。话句话说，一个增长率低的算法并不意味着它会消耗更小的运行时间。事实上，算法的复杂度并没有具体的计量单位，它只是表明当计算数据量的大小变化时，将如何影响算法消耗的资源。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://book.douban.com/subject/20432061/">算法导论</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;分析算法&quot;&gt;&lt;a href=&quot;#分析算法&quot; class=&quot;headerlink&quot; title=&quot;分析算法&quot;&gt;&lt;/a&gt;分析算法&lt;/h2&gt;&lt;p&gt;分析算法的结果意味着预测算法需要的资源。虽然我们有时主要关心像内存、通信带宽或计算机硬件这些资源，但通常我们想度量的是计算时间。一般来说，通过分析求解某个问题的几种候选算法，我们可以选出一种最有效的算法。这种分析可能指出不止一个可行的候选算法，但是在这个过程中，我们往往可以抛弃几个较差的算法。一般来说，算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入规模：输入规模的最佳概念依赖于研究的问题。对于许多问题，最自然的度量是输入中的项数，有时用两个数来描述一个算法的输入规模更为合适，如基于图的算法。&lt;/li&gt;
&lt;li&gt;运行时间：一个算法在特定输入的运行时间是指执行的基本操作数或步数。其中步数，采用以下观点，执行每一行代码需要常量执行时间。</summary>
    
    
    
    <category term="算法与数据结构" scheme="https://techcoffe.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL字符集的理解</title>
    <link href="https://techcoffe.com/2015/02/09/MySQL-Character-Sets/"/>
    <id>https://techcoffe.com/2015/02/09/MySQL-Character-Sets/</id>
    <published>2015-02-09T02:34:20.000Z</published>
    <updated>2020-08-22T03:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>字符(symbles)：人类语言的最小单位(不知道这样理解对不对，语言学的朋友请更正)</li><li>编码(encoding)：对给定的字符进行赋值或者说是建立一种映射关系。可以理解为一个过程,也可以理解为一个结果。例如：给定字符’A’和B’，我们给字符’A’和’B’各赋一个值，即有如下对应关系’A’=&gt;0, ‘B’=&gt;1。我们就说0是字符’A’的编码，1是字符’B’的编码。</li><li>字符集(character set)：字符和编码的集合(映射关系的集合)称为字符集。比如字符’A’和’B’同他们对应的编码组成的集合就是一个字符集。{‘A’=&gt;0, ‘B’=&gt;1}</li><li>校对规则(collation)：字符集中各个字符之间的比较与排列次序和方法。若果我们想比较字符串”A”和字符串”B”的大小。最简单的方法就是比较字符’A’和’字符B’对应编码的大小。比如上面的字符’B’的编码1大于字符’A’的编码0，我们就说字符串”A”大于字符串”B”。这中是最简单的一种校对规则，被称之为binary collation。其他复杂的校对规则原理与其类似，比如不去分字符的大小写等。<br>注：每一个校对规则都对应者一个字符集，而每个字符集可以对应多个校对规则。<a id="more"></a></li></ul><h2 id="MySQL中的字符集"><a href="#MySQL中的字符集" class="headerlink" title="MySQL中的字符集"></a>MySQL中的字符集</h2><p>MySQL中支持四个层次的字符集(MySQL4.1之后)分别是：服务器级(server)、数据库级(database)、表级(table)和连接级(connection)。当然还有一个特殊的字符串的字符集和校对规则。在MySQL查看当前字符集的设置情况可以使用<code>SHOW VARIABLES LIKE &#39;character%&#39;;</code>命令，如下图所示:<br><img src="/img/2018/10/mysql_character_set.png" alt="MySQL字符集"><br><strong>各个系统变量的含义:</strong></p><ul><li>character_set_client: 客户端数据传传过来使用的字符集</li><li>character_set_connection: 连接客户端和服务器之间接口使用的字符集</li><li>character_set_database: 当前选中数据库中使用的字符集</li><li>character_set_filesystem: 文件系统使用的字符集</li><li>character_set_results: 服务器返回给客户端结果的字符集</li><li>character_set_server: 服务器内部操作的字符集</li><li>character_set_system: 系统元数据(字段名等)使用的字符集</li></ul><h2 id="MySQL各个层次字符集作用规则"><a href="#MySQL各个层次字符集作用规则" class="headerlink" title="MySQL各个层次字符集作用规则"></a>MySQL各个层次字符集作用规则</h2><p><strong>服务器字符集和校对</strong></p><ul><li>当服务器启动时根据有效的选项设置</li><li>根据运行时设置<br>注: 启动mysqld时，根据使用的初始选项设置来确定服务器字符集和校对规则。可以使用–default-character-set设置字符集，并且可以在字符集后面为 校对规则添加–default-collation。如果没有指定一个字符集，那就与–default-character-set设置的值相同。如果你仅指定了一个字符集（例如，latin1），但是没有指定一个 校对规则，那就与–default-charset设置的值相同。</li></ul><p><strong>数据库字符集和校对</strong></p><ul><li>如果指定了CHARACTER SET X和COLLATE Y，那么采用字符集X和校对规则Y。</li><li>如果指定了CHARACTER SET X而没有指定COLLATE Y，那么采用CHARACTER SET X和CHARACTER SET X的默认校对规则。</li><li>如果指定了COLLATE Y而没有指定CHARACTER SET X，那么采用COLLATE Y相关的字符集和COLLATE Y校对规则。</li><li>否则，采用服务器字符集和服务器校对规则。</li></ul><p><strong>表字符集和校对</strong></p><ul><li>如果指定了CHARACTER SET X和COLLATE Y，那么采用CHARACTER SET X和COLLATE Y。</li><li>如果指定了CHARACTER SET X而没有指定COLLATE Y，那么采用CHARACTER SET X和CHARACTER SET X的默认校对规则。</li><li>如果指定了COLLATE Y而没有指定CHARACTER SET X，那么采用COLLATE Y相关的字符集和COLLATE Y校对规则。</li><li>否则，采用服务器字符集和服务器校对规则。</li></ul><p><strong>列字符集和校对</strong></p><ul><li>如果指定了CHARACTER SET X和COLLATE Y，那么采用CHARACTER SET X和COLLATE Y。</li><li>如果指定了CHARACTER SET X而没有指定COLLATE Y，那么采用CHARACTER SET X和default collation校对规则。</li><li>如果指定了COLLATE Y而没有指定CHARACTER SET X，那么采用同COLLATE Y相关的字符集和COLLATE Y校对规则。</li><li>否则，采用表字符集和表校对规则。</li></ul><p><strong>字符串文字字符集和校对</strong><br>一个字符串可能有一个可选的字符集引介词和COLLATE子句： [_charset_name]’string’ [COLLATE collation_name]</p><ul><li>如果指定了CHARACTER SET X和COLLATE Y，那么使用CHARACTER SET X和COLLATE Y。</li><li>如果指定了CHARACTER SET X而没有指定COLLATE Y，那么使用CHARACTER SET X和CHARACTER SET X的默认校对规则。</li><li>否则，采用表字符集和连接校对规则。</li></ul><h2 id="客户端与MySQL服务器交互过程中各种字符集起作用的节点"><a href="#客户端与MySQL服务器交互过程中各种字符集起作用的节点" class="headerlink" title="客户端与MySQL服务器交互过程中各种字符集起作用的节点"></a>客户端与MySQL服务器交互过程中各种字符集起作用的节点</h2><p><strong>客户端与MySQL服务器交互过程</strong></p><ol><li>客户端以character_set_client字符集将请求发送给MySQL服务器，MySQL服务器将其转换为character_set_connection字符集;</li><li>在进行内部数据处理前，按着字符集和校对规则将character_set_connection字符集转换为内部字符集和校对规则;</li><li>将操作结果以character_set_results字符集返回给客户端。</li></ol><p>具体过程如下图所示:<br><img src="/img/2018/10/character_set_points.png" alt="MySQL各个字符集作用节点"></p><h2 id="字符集注意的一些问题"><a href="#字符集注意的一些问题" class="headerlink" title="字符集注意的一些问题"></a>字符集注意的一些问题</h2><p><strong>乱码问题</strong><br>如果在各个阶段使用的字符集不同，那么很容易产生显示乱码或数据缺失问题(原因是各个字符集的映射关系与映射范围不同)。那么在进行操作时就应该对各种字符集进行设置。</p><ul><li>设置默认编码格式，对my.cnf文件进行修改，依次在修改[client]和[mysqld]<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-<span class="keyword">set</span>=utf8</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">character</span>-<span class="keyword">set</span>-<span class="keyword">server</span>=utf8</span><br><span class="line"><span class="keyword">collation</span>-<span class="keyword">server</span>=utf8_general_ci</span><br></pre></td></tr></table></figure></li><li>建立数据库时显式的指明所用的字符集<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db_name</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure></li><li>建表时显式的指明所用的字符集和校对<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_name (column_list)</span><br><span class="line">    [[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name]</span><br><span class="line">    [<span class="keyword">COLLATE</span> collation_name]]</span><br></pre></td></tr></table></figure></li><li>在PHP文件中使用<br>在php文件中使用mysql数据库时，在数据库建立连接后使用<code>mysql_query(&#39;set names utf8&#39;) ;</code>显式的设置连接的编码方式。一般情况下，中文就能正常显示了。</li></ul><p><strong>检查字符集一些常用命令</strong></p><ul><li>SHOW CHARACTER SET;</li><li>SHOW COLLATION;</li><li>SHOW VARIABLES LIKE ‘character%’;</li><li>SHOW VARIABLES LIKE ‘collation%’;</li><li>SQL函数HEX、LENGTH、CHAR_LENGTH</li><li>SQL函数CHARSET、COLLATION</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><p>[1] <a href="http://www.laruence.com/2008/01/05/12.html">深入MySQL字符集设置</a><br>[2] <a href="http://dev.mysql.com/doc/refman/5.5/en/globalization.html">MySQL5.5 Manual About Globalization</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;字符(symbles)：人类语言的最小单位(不知道这样理解对不对，语言学的朋友请更正)&lt;/li&gt;
&lt;li&gt;编码(encoding)：对给定的字符进行赋值或者说是建立一种映射关系。可以理解为一个过程,也可以理解为一个结果。例如：给定字符’A’和B’，我们给字符’A’和’B’各赋一个值，即有如下对应关系’A’=&amp;gt;0, ‘B’=&amp;gt;1。我们就说0是字符’A’的编码，1是字符’B’的编码。&lt;/li&gt;
&lt;li&gt;字符集(character set)：字符和编码的集合(映射关系的集合)称为字符集。比如字符’A’和’B’同他们对应的编码组成的集合就是一个字符集。{‘A’=&amp;gt;0, ‘B’=&amp;gt;1}&lt;/li&gt;
&lt;li&gt;校对规则(collation)：字符集中各个字符之间的比较与排列次序和方法。若果我们想比较字符串”A”和字符串”B”的大小。最简单的方法就是比较字符’A’和’字符B’对应编码的大小。比如上面的字符’B’的编码1大于字符’A’的编码0，我们就说字符串”A”大于字符串”B”。这中是最简单的一种校对规则，被称之为binary collation。其他复杂的校对规则原理与其类似，比如不去分字符的大小写等。&lt;br&gt;注：每一个校对规则都对应者一个字符集，而每个字符集可以对应多个校对规则。</summary>
    
    
    
    <category term="数据库" scheme="https://techcoffe.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
