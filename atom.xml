<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric的技术咖啡屋</title>
  <icon>https://www.gravatar.com/avatar/8e7764432bd2e4402b45b1dcc09c40ec</icon>
  <subtitle>未来有信心，长期有耐心。</subtitle>
  <link href="https://techcoffe.com/atom.xml" rel="self"/>
  
  <link href="https://techcoffe.com/"/>
  <updated>2024-06-18T09:59:45.239Z</updated>
  <id>https://techcoffe.com/</id>
  
  <author>
    <name>EricZhang</name>
    <email>zhpf@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的volatile与final</title>
    <link href="https://techcoffe.com/2019/05/30/Volatile-and-Final-in-Java/"/>
    <id>https://techcoffe.com/2019/05/30/Volatile-and-Final-in-Java/</id>
    <published>2019-05-30T00:25:54.000Z</published>
    <updated>2024-06-18T09:59:45.239Z</updated>
    
    <content type="html"><![CDATA[<p>Java在并发并发编程中，实现各个线程之间的安全可靠通信中，volatile、synchronized与final这三个原语起到了关键作用。可以说是Java在语言层面实现并发编程线程安全的基石。其中volatile与final更是基础中的基础，本文记录笔者在学习关于这部分一些整理。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当声明共享变量为volatile变量时，对这个变量的读、写将会变得很特别。特别之处主要体现在两个方面：其自身特性与其对内存可见性的影响。</p><a id="more"></a><h2 id="volatile自身特性"><a href="#volatile自身特性" class="headerlink" title="volatile自身特性"></a>volatile自身特性</h2><p>对一个volatile变量的读/写操作，与对一个普通变读/写操作使用同一个锁来同步，它们之间的执行效果相同。锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。volatile读写示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将val声明为64位volatile long型变量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> val = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个volatile变量写 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个volatile变量读 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 符合volatile读写(Read-Modify-Write) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* VolatileFeaturesExample与下面的CommonSyncExample等价*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonSyncExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将val声明为64位普通long型变量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> val = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个普通变量写(锁同步) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val =val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单个普通变量读(锁同步) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 普通变量读写(Read-Modify-Write) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> temp = getVal();</span><br><span class="line">        temp += <span class="number">1L</span>;</span><br><span class="line">        setVal(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。<br>对volatile自身的特性总结如下:</p><blockquote><p>可见性：对一个volatile变量的读，总能看到(任意线程)对这个volatile变量最后的写入；<br>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种符合操作不具有原子性。</p></blockquote><h2 id="volatile对内存可见性的影响"><a href="#volatile对内存可见性的影响" class="headerlink" title="volatile对内存可见性的影响"></a>volatile对内存可见性的影响</h2><p>volatile变量对可见性的影响比volatile变量本身更为重要。从JSR-133开始(即从JDK5开始)，volatile变量的写-读可以实现线程之间的通信。当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的。因此，从内存可见性(内存语义)的角度来看，volatile变量的读/写与锁的释放/获取具有相同的内存效果。</p><ul><li>volatile变量的写和锁的释放有相同的内存语义(冲刷处理器缓存)；<blockquote><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></blockquote></li><li>volatile变量的读和锁的获取有相同的内存语义(刷新处理器缓存)。<blockquote><p>当独一个volatile变量时，JMM会把该线程对应的本地内存置为无效(使无效化队列内容立即生效)，线程将从主内存中读取共享变量。</p></blockquote></li></ul><p>volatile变量的内存语义具体如何实现这里不做展开，详细内容可以参考<a href="https://www.infoq.cn/article/java_memory_model">深入理解Java内存模型</a>中所讲的内容。</p><p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。然而如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难理解。在有限的一些情形下使用volatile变量替代锁。要使 volatile变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>对变量的写操作不依赖于当前值；</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><blockquote><p>仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量的正确使用方式包括: ①确保它们自身状态的可见性，②确保它们所引用对象的状态的可见性；③以及标识一些重要的程序生命周期事件的发生。</p></blockquote><h2 id="volatile变量使用的典型模式"><a href="#volatile变量使用的典型模式" class="headerlink" title="volatile变量使用的典型模式"></a>volatile变量使用的典型模式</h2><p>volatile变量的使用典型模式可以参考参考资料[4]中的具体内容，以下对两个最常用的场景给出示例，volatile做为状态标志与安全发布。</p><p><strong>模式1：检查某个状态标志</strong></p><blockquote><p>该模式利用volatile变量的可见性与原子性，保证了对状态标志在多线程环境性下的正确读取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    shutdownRequested = <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式2：安全发布对象</strong></p><blockquote><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flooble</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> foo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Flooble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bar = <span class="number">1</span>;</span><br><span class="line">        foo = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 其他</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// 操作①：进行对象的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) <span class="comment">// 操作②：读取theFlooble变量并判断</span></span><br><span class="line">                doSomething(floobleLoader.theFlooble); <span class="comment">// 操作③：使用theFlooble进行业务处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设对initInBackground方法与doWork方法分别由线程A和线程B两个不同的线程执行。initInBackground方法只有一条语句:<br><code>theFlooble = new Flooble();</code>该语句可以分解为以下三个子操作(伪代码表示):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子操作①：分配Flooble实例所需的内存空间，并获得一个指向该空间的引用</span></span><br><span class="line">objRef = allocate(Flooble.class);</span><br><span class="line"><span class="comment">// 子操作②：调用Flooble类的构造器初始化objRef引用指向的Flooble实例</span></span><br><span class="line">invokeConstructor(objRef);</span><br><span class="line"><span class="comment">// 子操作③：将Flooble实例引用的objRef赋值给变量theFlooble</span></span><br><span class="line">theFlooble = objRef;</span><br></pre></td></tr></table></figure><p>假设theFlooble为普通变量不是volatile变量，那么由于JIT编译器可能将上述的子操作从排序为：子操作①-&gt;子操作③-&gt;子操作②，即在初始化对象完成之前将Flooble对象的引用写入实例变量theFlooble。那么线程B在执行doWork方法时，虽然floobleLoader.theFlooble变量值已经不为null，但此时获得的可能是一个未被完全初始化的实例。即该变量所引用的对象中的某些实例变量的变量值可能仍然是默认值，而不是构造其中设置的值。</p><p>由于theFlooble是volatile变量，因此同时保障该共享变量的可见性与有序性。</p><ul><li>可见性：线程A通过操作①修改了theFlooble变量的值，其它线程(编程B)可以读取到相应的值(通过操作②);</li><li>有序性：由于volatile能够禁止volatile变量写操作与该操作之前的任何读、写操作进行重排序，因此用volatile修饰theFlooble相当于禁止JIT编译器与处理器将子操作②(对对象进行初始化的写操作)重排序到子操作③(将对象的引用写入共享变量的写操作)，这保证了一个线程(线程B)读取到theFlooble变量所引用的实例时该实例已经初始化完毕。</li></ul><p>对于安全发布还有一个典型的例子就是双重检查锁定(Double-checked Locking，DCL)的单例模式。volatile保证了以下示例中的操作③与操作①不被重排序，具体分析同上面的安全发布。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 保存该类的唯一实例 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLSingleton instance;</span><br><span class="line">    <span class="comment">/* 私有构造器 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并返回该类的唯一实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 操作①</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DCLSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 操作② </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> DCLSingleton(); <span class="comment">// 操作③</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>对final域的读和写更像是对普通变量的访问。 对于final域，编译器和处理器要遵守两个重排序规则：</p><ul><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ul><p><strong>写final域的重排序规则</strong><br>写final域的重排序规则禁止把final域的写重排序到构造函数之外。JMM规定：<em>JMM禁止编译器把final域的写重排序到构造函数之外</em>。编译器的具体实现：编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。<br><strong>读final域的排序规则</strong><br>在一个线程中，初次读对象引用与初次读对象包含的final域，JMM规定：JMM禁止处理器重排序这两个操作(这里仅仅指处理器)，编译器会在读final域前插入一个LoadLoad屏障。</p><p>要达成写final域的重排序规则，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，我们看下面的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalVariableEscape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FinalVariableEscape obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalVariableEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>; <span class="comment">// 操作①</span></span><br><span class="line">        obj = <span class="keyword">this</span>; <span class="comment">// 操作②</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalVariableEscape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj != <span class="keyword">null</span> : obj.i ? <span class="number">0</span>; <span class="comment">// 操作③</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个线程A执行writer()方法，另一个线程B执行 reader()方法。这里的操作②使得对象还未完成构造前就为线程B可见。即使这里的操作②是构造函数的最后一步，且即使在程序中操作② 排在操作①后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作①和操作②之间可能被重排序。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a><br>[2] <a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a><br>[3] <a href="https://www.infoq.cn/article/java_memory_model">深入理解Java内存模型</a><br>[4] <a href="https://www.ibm.com/developerworks/java/library/j-jtp06197/index.html">Managing volatility</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java在并发并发编程中，实现各个线程之间的安全可靠通信中，volatile、synchronized与final这三个原语起到了关键作用。可以说是Java在语言层面实现并发编程线程安全的基石。其中volatile与final更是基础中的基础，本文记录笔者在学习关于这部分一些整理。&lt;/p&gt;
&lt;h1 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h1&gt;&lt;p&gt;Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当声明共享变量为volatile变量时，对这个变量的读、写将会变得很特别。特别之处主要体现在两个方面：其自身特性与其对内存可见性的影响。&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>缓存一致性</title>
    <link href="https://techcoffe.com/2019/05/07/Cache-Consistency/"/>
    <id>https://techcoffe.com/2019/05/07/Cache-Consistency/</id>
    <published>2019-05-07T14:47:15.000Z</published>
    <updated>2024-06-18T09:59:28.673Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对最近学习Java内存模型有关的内容进行的总结，该部分只包括处理器层缓存一致性相关的内容。这部分内容是更好的理解Java内存模型的前提。关于Java语言层内存模型相关的内容放到下一篇文章记录整理。</p><h1 id="处理器系统组织方式"><a href="#处理器系统组织方式" class="headerlink" title="处理器系统组织方式"></a>处理器系统组织方式</h1><p>多处理器系统存在多种组织方式，可以分为共享存储结构和非共享存储结构。对系统内存进行统一编址，进程可以直接访问本地节点和其他节点主存中的数据。非共享存储结构也可以共享主存，但是对于非本地节点的主存不能直接访问，需通过软件辅助间接访问，时间开销较大。共享存储的多处理器系统还可以分为集中式共享存储结构和分布式共享存储结构。其中集中式共享存储结构又称为均匀访存延迟的存储结构(UMA)，又可分为并行向量处理机(PVP)和对称多处理器系统(SMP)。分布式共享存储结构包括非均匀访存延迟的存储结构(NUMA)和无远程访问结构(NORMA)。下图对以上分类进行了总结：</p><a id="more"></a><img src="/img/2019/5/多处理器系统组成分类.png" alt="图1-多处理器系统组成分类" width="80%"><h1 id="处理器存储结构"><a href="#处理器存储结构" class="headerlink" title="处理器存储结构"></a>处理器存储结构</h1><p>我们知道计算机在程序执行时，每一条指令都在CPU中执行，执行时需要的数据需要从系统内存中获取。但是随着技术的不断演进，人们发现存储器的读写速度与处理器的指令执行速度差距越来越大，这就导致CPU每次执行内存相关的操作都要耗费很长的时间。经过不断的摸索，人们想出了一个好办法，就是在处理器和内存之间插入高速缓存。当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。随着处理器处理速度的不断提高，逐步出现了一级缓存、二级缓存与三级缓存。下图是多核多处理器的缓存结构示意图:<br><img src="/img/2019/5/多核处理器缓存结构.png" alt="图2-多核处理器缓存结构" width="80%"><br>有了多级缓存之后，程序执行时当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</p><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p>引入缓存解决了处理器执行速度与内存读写速度的执行瓶颈的问题，但缓存的引入同时也带来了新的问题：<em>缓存一致性</em>。在共享存储的多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存或三级缓存。当多个线程并发访问同一个共享变量的时候，这些线程的执行处理器上的高速缓存各自都会保留一份改共享变量的副本，一个处理器对其副本数据进行更新之后，其它处理器如何“觉察”到该更新并做出适当反应，以确保这些处理器后续读取该共享变量时能够读取到这个更新。这就是上面提到的缓存一致性问题，其实质就是如何防止读脏数据和丢失更新的问题。<br>维护一致性有<strong>写直达WT（Write Through）</strong>和<strong>写回WB（Write Back）</strong>两种高速缓存：写直达高速缓存采用的策略是一旦高速缓存中的一个字被修改过，则在主存中要立即修改；而写回高速缓存的策略是对高速缓存的修改延迟到被修改的字从高速缓存中被替换或消除时，才真正修改主存。<br>具体示例如图3所示，图3显示三个带有私有高速缓存的处理器，其高速缓存通过总线与共享主存相连。考虑主存中的一个位置u和以下的一系列处理器发出的访问u的指令：首先，P1从主存中读u，从而P1的高速缓存中建立了一个u的拷贝；然后，P3从主存中读u，从而在P3的高速缓存中也建立了一个u的拷贝；接着，P3向主存写u，将u值从5改写为7。下面我们根据高速缓存类型分情况讨论：</p><ul><li>采用写直达高速缓存：<blockquote><p>P3写u时，将直接更新主存，然后当P1再一次读u时（动作 4），将读到无效值5，而不是主存中的当前值7；</p></blockquote></li><li>采用写回高速缓存：<blockquote><p>P3写u时，标记为脏（dirty），暂时把修改过的（脏的）值放在自己的高速缓存中，并不直接更新主存。只有当u所在的块被从高速缓存中替换出去时，才将其值写回主存。这样一来，不仅P1再次读时将读到旧值，而且P2读u（动作5）时，也从主存读到旧值5，而不是新值7。最后，如果多个处理器对在写回高速缓存中的u写了一系列值，则最终主存中是哪个值，将取决于u所在高速缓存块被替换的次序，而与对u的写操作的发生次序无关。</p></blockquote></li></ul><img src="/img/2019/5/缓存一致性读写示例.png" alt="图3-缓存一致性读写示例" width="80%"><h1 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h1><p>为了解决缓存不一致的这类问题，处理器之间需要一种约束(通信机制)——*缓存一致性协议(Cache Coherence Protocol)*。高速缓存一致性协议中广泛采用的有两类协议——基于目录的协议和基于侦听的协议。</p><ul><li>基于目录的协议<blockquote><p>对于共享存储其中的数据块设置目录项来跟踪、记录其状态信息，从而知道哪些节点应该对请求做出何种操作。目录协议的实现方案较多，根据目录存储方法的不同可以分为集中式目录协议(如Tang)、分布式目录协议(如Censiert)等。</p></blockquote></li><li>基于侦听的协议<blockquote><p>另一种多核处理器中维护高速缓存一致性的常用方法。具体来说，缓存控制器通过共享总线事务来更新本地数据的一致性状态。这里，高速缓存一致性的维护可以看作是一组有限状态机的状态变迁。挂接在总线上的节点接收到一致性请求后，会根据消息类型和自身状态，更新数据状态并向请求者做出响应。避免出现缓存内容不一致的方案有两种，分别为“写作废”与“写更新”。“写作废”是将所有远程拥有相同数据块副本的缓存中对应内容“作废”，使有效数据只有一个，典型的协议有MSI协议和MESI协议等；“写更新”是将存有相同数据块副本的缓存中对应内容“更新”，可能出现多个有效数据。典型的协议有Dragon等。不过，“写更新”方案需要将更新内容发送到所有须更新的缓存中，会大大增加总线的负担，一般使用得不多。</p></blockquote></li></ul><p>在侦听协议设计中，主要有两种设计选择：①是写直达高速缓存，还是写回高速缓存；②是写无效WI（Write-Invalidate），还是写更新WU（Write-Update）协议。以下我们讨论一下这两种设计选择。<br>我们将对写直达和写回分别进行分析：在写直达方式下，主存总是与高速缓存中的最新值保持一致，但这种方式在每次高速缓存的写操作后，都需要更新主存从而需要额外的总线周期；在写回方式下，主存的更新要到发生替换时才进行，因此在高速缓存的写操作命中后的瞬间，高速缓存和主存是不一致的。写回实际上尽量延迟写直达中对主存的更新，因此它只需占有较少的总线周期，故在存储器总线结构上采用写回高速缓存更经济。<br>另一个主要的选择是采用写无效还是写更新协议：写无效协议在本地高速缓存中数据被更新后，使所有其他高速缓存中的相应数据拷贝无效，接下来由同一个处理器发出的对该内存块的写操作就不会在总线上引起任何通信；写更新协议则广播修改后的数据，以更新所有的高速缓存中的相应数据拷贝，因此当拥有该块拷贝的处理器接下来存取这个新数据时，存取延迟就很小。另外，由于一个总线事务就能更新所有拥有该块的高速缓存中内容，因此如果该块有多个共享者，则能极大节约总线带宽。<br>具体分类如图4所示。<br><img src="/img/2019/5/缓存一致性协议分类.png" alt="图4-缓存一致性协议分类" width="80%"><br>基于侦听的缓存一致性协议主要有MSI协议、MESI协议、MESIF协议、MOESI协议，其中MESIF协议与MOESI协议分别是Intel Core i7处理器与AMD Opteron处理器对MESI协议的优化。下面重点介绍经典的缓存一致性协议——MESI协议。</p><h1 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h1><p>单核Cache中每个Cache line有2个标志：dirty和valid标志，它们很好的描述了Cache和Memory(内存)之间的数据关系(数据是否有效，数据是否被修改)，而在多核处理器中，多个核会共享一些数据，MESI协议就包含了描述共享的状态。为了保障数据的一致性，MESI协议将缓存条目的状态划分为Modified、Exclusive、Shared和Invalid4种，并在此基础上定义了一组消息用于协调各个处理器的读写请求。MESI协议中四个状态具体含义如下:</p><ul><li>Invalid(无效的，记为I)：该状态表示相应缓存行中不包含任何内存地址对应的有效副本数据。该状态是缓存条目的初始数据。</li><li>Shared(共享的，记为S)：该状态表示相应缓存行包含相应内存地址所对应的副本数据。并且，其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据。因此，一个缓存条目的状态如果为Shared，并且其他处理器上也存在Tag值与该缓存条目的Tag值相同的缓存条目，那么这些缓存条目的状态也为Shared。<em>处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。</em></li><li>Exclusive(独占的，记为E)：该状态表示相应缓存行包含相应内存地址所对应的副本数据。并且该缓存行以独占的方式保留了相应内存地址的副本数据，即其它所有处理器上的高速缓存当前都不保留该数据的有效副本。<em>处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。</em></li><li>Modified(更改过的，记为M)：该状态表示相应的缓存行包含对相应内存地址所做的更新。由于MESI协议中任意一个时刻只能有一个处理器对同一内存地址对应的数据进行更新，因此在多个处理器上的高速缓存中Tag值相同的缓存条目中，任意一个时刻只能有一个缓存条目处于该状态。<em>处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据不一致。</em></li></ul><p>MESI协议各个状态之间的转换关系如图5所示，详细的转换过程不再描述，可以参考相应的资料，如《Java多线程编程实战指南-核心篇》。<br><img src="/img/2019/5/MESI协议状态机.png" alt="图5-MESI协议状态机" width="80%"></p><h1 id="硬件缓冲区：写缓冲器与无效化队列"><a href="#硬件缓冲区：写缓冲器与无效化队列" class="headerlink" title="硬件缓冲区：写缓冲器与无效化队列"></a>硬件缓冲区：写缓冲器与无效化队列</h1><p>MESI协议解决了缓存一致性问题，但是其自身也存在一个性能弱点：处理器执行写内存操作时，必须等待其他所有处理器将其高速缓存中的相应副本数据删除并接收到这些处理器回复的Invalidate Acknowledge/Read Response消息之后才能将数据写入高速缓存。为了规避和减少这种等待造成的写操作的延迟，硬件设计者引入了写缓冲器与无效化队列。</p><ul><li>写缓冲器：是处理器内部的私有高速存储部件，每个处理器都有其写缓冲器，写缓冲器内部可包含若干条目。一个处理器无法读取其他处理器上写缓冲器中的内容。</li><li>无效化队列：处理器在接收到Invalidate消息之后并不删除消息中指定地址对应的副本数据，而是将消息存入无效化队列之后就回复Acknowledge消息，从而减少了写操作执行处理器所需的等待时间。是否存在无效化队列视各个处理器的设计。</li></ul><p>引入写缓冲器与无效化队列后的处理器结构如图6所示。<br><img src="/img/2019/5/写缓冲器与无效化队列.png" alt="图6-写缓冲器与无效化队列" width="50%"></p><h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>引入写缓冲器与无效化队列后带了一些新的问题：内存重排序与可见性问题。为了解决重此类问题便引入了内存屏障指令。内存屏障分为两类：</p><ul><li>存储屏障：写线程的执行处理器所执行的存储屏障保障了该线程对共享变量所做的更新对读线程来说是同步的(冲刷处理器缓存)；</li><li>加载屏障：读线程的执行处理器所执行的加载屏障将写线程对共享变量所做的更新同步到该处理器的高速缓存之中(刷新处理器缓存)。<br>主要包括：LoadLoad屏障、LoadStore屏障、StoreStore屏障和StoreLoad屏障。</li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>[1] <a href="https://os.inf.tu-dresden.de/Studium/DOS/SS2011/02-Coherency.pdf">Advanced Systems Programming: Quick Poll</a><br>[2] <a href="https://www.hollischuang.com/archives/2550">再有人问你Java内存模型是什么，就把这篇文章发给他</a><br>[3] 周君，唐士斌，商用多核处理器中的存储器一致性模型与高速缓存同一性协议。信息技术快报，Vol.11 No.1<br>[3] <a href="https://book.douban.com/subject/27034721/">Java多线程编程实战指南-核心篇</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对最近学习Java内存模型有关的内容进行的总结，该部分只包括处理器层缓存一致性相关的内容。这部分内容是更好的理解Java内存模型的前提。关于Java语言层内存模型相关的内容放到下一篇文章记录整理。&lt;/p&gt;
&lt;h1 id=&quot;处理器系统组织方式&quot;&gt;&lt;a href=&quot;#处理器系统组织方式&quot; class=&quot;headerlink&quot; title=&quot;处理器系统组织方式&quot;&gt;&lt;/a&gt;处理器系统组织方式&lt;/h1&gt;&lt;p&gt;多处理器系统存在多种组织方式，可以分为共享存储结构和非共享存储结构。对系统内存进行统一编址，进程可以直接访问本地节点和其他节点主存中的数据。非共享存储结构也可以共享主存，但是对于非本地节点的主存不能直接访问，需通过软件辅助间接访问，时间开销较大。共享存储的多处理器系统还可以分为集中式共享存储结构和分布式共享存储结构。其中集中式共享存储结构又称为均匀访存延迟的存储结构(UMA)，又可分为并行向量处理机(PVP)和对称多处理器系统(SMP)。分布式共享存储结构包括非均匀访存延迟的存储结构(NUMA)和无远程访问结构(NORMA)。下图对以上分类进行了总结：&lt;/p&gt;</summary>
    
    
    
    <category term="Java基础" scheme="https://techcoffe.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
