<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Eric的技术咖啡屋</title>
  <meta name="author" content="EricZhang">
  
  <meta name="description" content="Eric的技术咖啡屋 | Java | Go | 后端开发 | 架构师">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Eric的技术咖啡屋"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Eric的技术咖啡屋" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.0.2"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Eric的技术咖啡屋</a></h1>
  <h2><a href="/">未来有信心，长期有耐心。</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="//">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于我</a></li>
    
    <li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-08-22T03:36:32.000Z"><a href="/2020/08/22/Summary-of-Singleton-Pattern/">2020-08-22</a></time>
      
      
  
    <h1 class="title"><a href="/2020/08/22/Summary-of-Singleton-Pattern/">单例模式总结</a></h1>
  

    </header>
    <div class="entry">
      
        <p>单例模式是大家平时经常在工程中见到与使用的一种设计模式。本文的目的是介绍单例模式的各种实现方式以及每种实现方式涉及到的问题点。首先我们看下单例模式的定义。</p>
<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>单例模式：保证一个类仅有一个示例，并提供一个访问它的全局访问点。</p>
<blockquote>
<p>通常我们可以让一个全局变量使得一个变量被访问，但它不能防止你实例化多个对象。一个最好的方法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其它实例能够被创建，并且它可以提供一个访问该实例的方法。</p>
</blockquote>
<p>单例模式的uml图如下所示：<br><img src="/img/2020/8/singleton.png" alt="图1-单例模式" width="60%"></p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>考虑到不同的使用场景与环境，单例模式的实现也是多种多样，需要我们根据具体的场景进行相应的选择。接下来就对不同场景下单例模式的实现以及每种实现方式的存在的问题进行介绍。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2020/08/22/Summary-of-Singleton-Pattern/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-05-30T00:25:54.000Z"><a href="/2019/05/30/Volatile-and-Final-in-Java/">2019-05-30</a></time>
      
      
  
    <h1 class="title"><a href="/2019/05/30/Volatile-and-Final-in-Java/">Java中的volatile与final</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Java在并发并发编程中，实现各个线程之间的安全可靠通信中，volatile、synchronized与final这三个原语起到了关键作用。可以说是Java在语言层面实现并发编程线程安全的基石。其中volatile与final更是基础中的基础，本文记录笔者在学习关于这部分一些整理。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Java语言中的volatile变量可以被看作是一种“程度较轻的synchronized”；与synchronized块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当声明共享变量为volatile变量时，对这个变量的读、写将会变得很特别。特别之处主要体现在两个方面：其自身特性与其对内存可见性的影响。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2019/05/30/Volatile-and-Final-in-Java/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-05-07T14:47:15.000Z"><a href="/2019/05/07/Cache-Consistency/">2019-05-07</a></time>
      
      
  
    <h1 class="title"><a href="/2019/05/07/Cache-Consistency/">缓存一致性</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文是对最近学习Java内存模型有关的内容进行的总结，该部分只包括处理器层缓存一致性相关的内容。这部分内容是更好的理解Java内存模型的前提。关于Java语言层内存模型相关的内容放到下一篇文章记录整理。</p>
<h2 id="处理器系统组织方式"><a href="#处理器系统组织方式" class="headerlink" title="处理器系统组织方式"></a>处理器系统组织方式</h2><p>多处理器系统存在多种组织方式，可以分为共享存储结构和非共享存储结构。对系统内存进行统一编址，进程可以直接访问本地节点和其他节点主存中的数据。非共享存储结构也可以共享主存，但是对于非本地节点的主存不能直接访问，需通过软件辅助间接访问，时间开销较大。共享存储的多处理器系统还可以分为集中式共享存储结构和分布式共享存储结构。其中集中式共享存储结构又称为均匀访存延迟的存储结构(UMA)，又可分为并行向量处理机(PVP)和对称多处理器系统(SMP)。分布式共享存储结构包括非均匀访存延迟的存储结构(NUMA)和无远程访问结构(NORMA)。下图对以上分类进行了总结：</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2019/05/07/Cache-Consistency/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-30T00:54:09.000Z"><a href="/2019/04/30/Notes-of-Java-Concurrency-in-Practice/">2019-04-30</a></time>
      
      
  
    <h1 class="title"><a href="/2019/04/30/Notes-of-Java-Concurrency-in-Practice/">Java并发编程实战笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="1-线程安全性"><a href="#1-线程安全性" class="headerlink" title="1. 线程安全性"></a>1. 线程安全性</h2><ul>
<li><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li>
</ul>
<p>线程安全性：当多个线程访问某个类时，这个类始终能表现出正确的行为，那么就称这个类是线程安全的。</p>
<blockquote>
<p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
</blockquote>
<ul>
<li><h3 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h3></li>
</ul>
<p>在第二章讲线程安全性中关于锁重入有这样一个示例(2.3.2):</p>
<blockquote>
<p>子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。由于Widget和LoggingWidget中doSomething方法都是synchronized方法，<em>因此每个doSomething方法在执行前都会获取Widget上的锁。</em>因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远无法获取的锁。重入则避免了这种情况的发生。</p>
</blockquote>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2019/04/30/Notes-of-Java-Concurrency-in-Practice/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-03T01:15:32.000Z"><a href="/2019/03/03/Characteristic-of-Java8-Lambda/">2019-03-03</a></time>
      
      
  
    <h1 class="title"><a href="/2019/03/03/Characteristic-of-Java8-Lambda/">Java8特性-Lambda表达式</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul>
<li>行为参数化</li>
<li>函数式编程</li>
<li>流处理</li>
</ul>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><ul>
<li>没有共享的可变数据，将方法和函数即代码传递给其他方法的能力是函数式编程范式的基石。</li>
<li>编写把函数作为一等值传递的程序。</li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>为什么叫Lambda表达式(为什么用字母λ)：源于计算机科学家Alonzo Church，后来带参数变量的表达式就称为Lambda表达式。<br>理论上来说，你在Java 8之前做不了的事情，Lambda也做不了。但是，现在你用不着再用匿名类写一堆笨重的代码。Lambda表达式本身的类型：函数式接口。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2019/03/03/Characteristic-of-Java8-Lambda/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-03T00:09:02.000Z"><a href="/2019/03/03/Java-Generic/">2019-03-03</a></time>
      
      
  
    <h1 class="title"><a href="/2019/03/03/Java-Generic/">Java泛型</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>Java 1.5发行版中增加了泛型(Generic)。在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转换，并在编译时告知是否插入了类型错误的对象。这样可以使程序既更加安全，也更加清楚。为了更清楚的说明以上表述，我们通过例子来看下，引入泛型前后的对比：</p>
<ul>
<li>避免了类型转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①引入泛型之前需要对读取的内容进行类型转换</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s = (String) list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②引入泛型之后不需要进行类型转换</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s = list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure></li>
<li>错误检查前置到编译阶段<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ①使用泛型</span></span><br><span class="line">        Comparable&lt;Date&gt; c1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(c1.compareTo(<span class="string">&quot;red&quot;</span>)); <span class="comment">//编译错误</span></span><br><span class="line">        <span class="comment">// ②未使用泛型</span></span><br><span class="line">        Comparable c2 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(c2.compareTo(<span class="string">&quot;red&quot;</span>)); <span class="comment">//运行时错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2019/03/03/Java-Generic/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-23T06:31:31.000Z"><a href="/2016/04/23/Algorithm-Basic/">2016-04-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/23/Algorithm-Basic/">算法基础</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="分析算法"><a href="#分析算法" class="headerlink" title="分析算法"></a>分析算法</h2><p>分析算法的结果意味着预测算法需要的资源。虽然我们有时主要关心像内存、通信带宽或计算机硬件这些资源，但通常我们想度量的是计算时间。一般来说，通过分析求解某个问题的几种候选算法，我们可以选出一种最有效的算法。这种分析可能指出不止一个可行的候选算法，但是在这个过程中，我们往往可以抛弃几个较差的算法。一般来说，算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。</p>
<ul>
<li>输入规模：输入规模的最佳概念依赖于研究的问题。对于许多问题，最自然的度量是输入中的项数，有时用两个数来描述一个算法的输入规模更为合适，如基于图的算法。</li>
<li>运行时间：一个算法在特定输入的运行时间是指执行的基本操作数或步数。其中步数，采用以下观点，执行每一行代码需要常量执行时间。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/04/23/Algorithm-Basic/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-09T02:34:20.000Z"><a href="/2015/02/09/MySQL-Character-Sets/">2015-02-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/02/09/MySQL-Character-Sets/">MySQL字符集的理解</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>字符(symbles)：人类语言的最小单位(不知道这样理解对不对，语言学的朋友请更正)</li>
<li>编码(encoding)：对给定的字符进行赋值或者说是建立一种映射关系。可以理解为一个过程,也可以理解为一个结果。例如：给定字符’A’和B’，我们给字符’A’和’B’各赋一个值，即有如下对应关系’A’=&gt;0, ‘B’=&gt;1。我们就说0是字符’A’的编码，1是字符’B’的编码。</li>
<li>字符集(character set)：字符和编码的集合(映射关系的集合)称为字符集。比如字符’A’和’B’同他们对应的编码组成的集合就是一个字符集。{‘A’=&gt;0, ‘B’=&gt;1}</li>
<li>校对规则(collation)：字符集中各个字符之间的比较与排列次序和方法。若果我们想比较字符串”A”和字符串”B”的大小。最简单的方法就是比较字符’A’和’字符B’对应编码的大小。比如上面的字符’B’的编码1大于字符’A’的编码0，我们就说字符串”A”大于字符串”B”。这中是最简单的一种校对规则，被称之为binary collation。其他复杂的校对规则原理与其类似，比如不去分字符的大小写等。<br>注：每一个校对规则都对应者一个字符集，而每个字符集可以对应多个校对规则。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/02/09/MySQL-Character-Sets/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:techcoffe.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Java基础/">Java基础</a><small>5</small></li>
  
    <li><a href="/categories/数据库/">数据库</a><small>1</small></li>
  
    <li><a href="/categories/算法与数据结构/">算法与数据结构</a><small>1</small></li>
  
    <li><a href="/categories/设计模式/">设计模式</a><small>1</small></li>
  
  </ul>
</div>


  <div class="widget tag">
    <h2 class="title">联系方式</h2>
    <ul class="entry">
        <li>Email: <a href="Mailto:root@ericvip.com">root@ericvip.com</a></li>
        <li>Github: <a href="https://github.com/dreamshield/" title="eric" target="_blank">@EricZhang</a></li>
    </ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2024 EricZhang
  
  
    |
<script type="text/javascript" src="https://s96.cnzz.com/z_stat.php?id=1277384850&web_id=1277384850"></script>

  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
