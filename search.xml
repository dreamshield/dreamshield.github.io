<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式之适配器模式</title>
      <link href="/2024/12/23/Design-Pattern-of-Adapter/"/>
      <url>/2024/12/23/Design-Pattern-of-Adapter/</url>
      
        <content type="html"><![CDATA[<p>适配器模式是一种结构型设计模式，用于在接口不兼容的情况下，让原本无法协作的类能够一起工作。适配器模式通过在两个不兼容的接口之间搭建桥梁，使得一个类的接口可以被客户端以期望的接口形式所使用。核心思想是将现有类的接口转换为客户端期望的接口。</p><span id="more"></span><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>接口不兼容<br>当已有的类不能满足客户端的接口要求时，使用适配器进行接口转换。</li><li>代码复用<br>希望复用现有类的功能，但接口与目标接口不一致。</li><li>引入第三方类库<br>需要将第三方库的接口转换为自己系统的接口。</li><li>遗留系统整合<br>在新系统中需要使用旧系统的功能，但旧系统的接口不兼容。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>在适配器模式中，通常有以下角色：Target、Adaptee、Adapter和Client。各角色的说明如下表：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>Target(目标接口)</td><td>定义了业务中需要使用方法，是对整体业务规则的约束。</td></tr><tr><td>Adaptee(被适配者)</td><td>业务中已有的接口或实例，需要基于该接口或实例对目标(Target)接口进行适配。</td></tr><tr><td>Adapter(适配器)</td><td>Target与Adaptee之间的桥梁，完成从Adaptee到Target逻辑转换。</td></tr><tr><td>Client(请求者)</td><td>实际业务发起方，使用Target定义的方法进行业务处理。</td></tr></tbody></table><p> Adapter依赖具体的Adaptee实现Target接口约定的规则，客户端面向Target接口编程屏蔽了不同具体适配器底层实现逻辑。业务执行过程中根据不同场景，选出合适的适配器进行业务逻辑处理。</p><p>适配模式根据具体实现有两种形式：类适配器与实例适配器。二者的核心区别在于：类适配器通过继承实现适配，而实例适配器通过组合实现适配。由于类适配器模式直接继承了被适配类，导致子类不够灵活。</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>通过继承实现适配。</li><li>适配器继承自 Adaptee 类，同时实现 Target 接口。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>静态绑定：适配器与被适配者在编译时绑定。</li><li>只能适配一个类：由于 Java 不支持多继承，适配器类只能继承一个被适配者类。</li><li>更直接：继承机制允许适配器直接访问被适配者的功能。</li></ul><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>单一被适配者：只有一个需要适配的类。</li><li>无需修改被适配者：适配器直接继承被适配者，可以对其进行增强，而不修改其代码。</li><li>不需要动态替换被适配者：被适配者类型是固定的。</li></ul><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><img  src=http://www.plantuml.com/plantuml/svg/AyaioKbLUBvnzyk6ffUjlKzdhk3YoimhIIrAIqnELGX9B4fFBL6evb800cs5ilpC58KIi9XlQab6Veg69bSj5rToJc9niO9ZIc91IMeggkBYecHSAei86GkrtAP6Jm-cXGjcYKsDhYvSaCiv9pCrhqH1rmxcO2k5qk9K966OZLOAoKMfYIMfN000><h3 id="实例适配器"><a href="#实例适配器" class="headerlink" title="实例适配器"></a>实例适配器</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>通过组合实现适配。</li><li>适配器持有 Adaptee 的实例，调用 Adaptee 的方法进行适配。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>动态绑定：适配器和被适配者在运行时绑定。</li><li>支持多被适配者：可以通过持有不同的 Adaptee 实例，实现适配不同的类。</li><li>灵活性更高：可以动态替换 Adaptee 实例，而无需修改适配器代码。</li></ul><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>多个被适配者：需要适配多个类，可以通过持有不同实例实现。</li><li>需要动态替换被适配者：适配器可以在运行时使用不同的 Adaptee。</li><li>无法修改被适配者：适配器通过组合而不是继承，避免对被适配者的直接依赖。</li></ul><h4 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h4><img  src=http://www.plantuml.com/plantuml/svg/AyaioKbLUBfktfDztIyRcbwszZwTkOABApEl9BKeBJ4vLI4aiIWzjKIXcai12BGLol8pKnHAm6A-gIKP-IaQcborN5p9EOd5nGgEAOa59Qcfg8gBYv9ngImYP2pKSfiQFJsO5YwOLYrTNJkOZLnSpZcPgNab2a0Xg1uhXTBYL2HXc3OhXUIYrCIIL2u0><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>下面通过适配器模式在实际代码中的具体应用对其进行分析，由于类适配器模式直接继承了被适配类，限制了其灵活性、可维护性和可扩展性，因此很少在实际中使用，这里不做过多分析。</p><p>Spring MVC的核心DispatcherServlet使用了适配器模式来支持多种类型的请求处理器。这主要体现在HandlerAdapter接口和其具体实现上，它负责将不同类型的Handler（控制器）统一适配为可以被DispatcherServlet调用的格式。解决了Spring MVC中支持多种控制器类型的需求，解耦了DispatcherServlet和具体控制器的实现。</p><h3 id="实例UML图"><a href="#实例UML图" class="headerlink" title="实例UML图"></a>实例UML图</h3><img  src=http://www.plantuml.com/plantuml/svg/XLFDIiGm4BxdAUReN_i0AiAo2YjO15VqdBQZZSGa9hCgg222H_NiHV3cINm0NsULVGkpfglRrgszjCny-NvcKX8a4Vh62dK8oLvtT7qpkhqRFhvyl3mFtn-6hq-Vzs-CPP8x1xlS7YB5YSvHTbI-9_0CBguO4uhG7l0C9uWULxb4sycvyHsuOE2VHKYrbiWLk84nsfARsqwFC2Ce0dn-fSHL149phaTa-cXF9T8EdWpG4TZmNe9Apncj7Ffc-5Y2cWXGOVMPWutp30q9hIQgKliHUFTRt95t80u4vgso3VT-5BNaKRHMJRCCcKLE28pnr97bdY0CjpmITyfooPGW5Jh_cUGLgw9BKmatnc-mFlSwkY-EZSIkLcIrzC0clXvWzJAEeSqIQ_MxUXb5qERnJxrsczFtBPGm_iNMGsDShc_V1lqgj4bLoJ6JRLETweod4XjmDYKGqipIPzMpq-2_wHbhNVU2dtKL_y--nmUct4v-ywuKg2XU5yvmoWgqfQdlTCtg-8xNY9TXu91z0G00><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>HandlerAdapter是适配器需要实现的目标接口，定义了目标业务需要用到的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前适配器是否支持指定的Handler类型。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    <span class="comment">// 适配器实际调用Handler的方法，处理请求并返回ModelAndView。</span></span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的适配器实例需要实现HandlerAdapter接口，如SimpleControllerHandlerAdapter。在具体的适配器实例中，调用自身被适配类型响应方法进行实际的业务逻辑处理。如SimpleControllerHandlerAdapter中的Controller实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在DispatcherServlet的doDispatch()方法中定义了整个业务处理流程，简化流程如下：</p><ul><li>step1：从HandlerMapping中确定当前请求对应的Handler。</li><li>step2：根据Handler获取对应的HandlerAdapter。</li><li>step3：调用具体适配器，完成请求处理并返回结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step1：获取当前请求对应的Handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step2：根据Handler获取对应的HandlerAdapter</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// http get请求的缓存处理</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step3：调用具体适配器，完成请求处理并返回结果</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果处理</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 资源释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之迭代器模式</title>
      <link href="/2024/12/16/Design-Pattern-of-Iterator/"/>
      <url>/2024/12/16/Design-Pattern-of-Iterator/</url>
      
        <content type="html"><![CDATA[<p>迭代器模式（Iterator Pattern）是一种行为设计模式，用于提供一种按着某种方式访问聚合对象中元素的方法，而不暴露该聚合对象底层实现。通过迭代器模式，客户端可以以统一的方式遍历不同集合（如数组、链表等），无需关心集合的内部表示。</p><span id="more"></span><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>简化复杂数据结构的访问<br>客户端只关系元素的遍历，不需要了解复杂的集合实现，将针对集合元素的遍历逻辑与集合的具体实现解耦。</li><li>提供多种遍历与访问方式<br>针对同一集合提供多方式(正序、逆序、跳步等)对集合中的元素进行访问。</li><li>集合类型的多样化<br>客户端以一致的方式处理不同类型的集合，而无需关心不同类型集合内部的实现。修改集合类型时，客户端中针对集合遍历的代码无需修改，符合开闭原则。</li></ul><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img  src=http://www.plantuml.com/plantuml/svg/AyaioKbLUB5_xPFTYv_ENF5inSAdU_gvk3BpIbABqXAJKnKyWOp4almY6rSxXMek1I3GLaZApyz9JSnJo4WizakjAD7GX8gxAkH1kBLSNCavYSN52ixvUSb5gIMfv9e2qwTWKwEdXs4QYZiTqzEBKjCJIrAHxK2sDnFAnkO-4ZKZB4Dr65mOHOckhXtSB0Kh1Q1Ai0eCJGeskhhvM3oPd9EPcbU2RanfSIgA3C8Oi1m0><p>上图中各角色说明如下表：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>迭代器接口：Iterator</td><td>迭代器约束，定义了需要实现的遍历方式。</td></tr><tr><td>迭代器实现：ConcreteIterator</td><td>对迭代器定义的遍历方式的具体实现，需要感知聚合类的内部具体实现。</td></tr><tr><td>聚合接口：IAggregate</td><td>定义了产生迭代器角色的接口，根据业务需要返回不同的迭代器。</td></tr><tr><td>聚合实现：ConcretdAggregate</td><td>负责实现聚合接口约束，创建具体的迭代器实例。同时可以根据业务需要返回不同类型的迭代器实例。</td></tr><tr><td>客户端：client</td><td>使用聚合与迭代器完成业务需要的遍历逻辑。</td></tr></tbody></table><p>迭代器模式的关键在于实现Iterator与IAggregate中的关键方法：</p><ul><li>Iterator接口：<ul><li>boolean hasNext()：用于判断是否还有下一个元素。</li><li>E next()：获取下一个元素。</li></ul></li><li>IAggregate接口：<ul><li>Iterator createIterator()：创建一个迭代器对象。</li></ul></li></ul><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>在java的集合框架JUC中，很多集合类(如ArrayList、LinkedList、HashSet等)都提供了iterator方法，用于返回Iterator实例。下面以ArrayList源码进行分析。</p><h3 id="实例UML图"><a href="#实例UML图" class="headerlink" title="实例UML图"></a>实例UML图</h3><img  src=http://www.plantuml.com/plantuml/svg/pLCnJiGm4EpzYYqFeTm383hfX594GeY23pZ98YoP6DacEWHyWPw6XeO6H4_1PpZ1CuXZ9x6JGtVfI6NFxknEPjUQQOwmb9BU73EbVpvVlpwUruylwxUdxuTtGbYfKPxJ726j3pJZ69yju9P0_UrRJ0jfCEREixr3SkyJZmJdc6icoZYPI3MIDfAI4ObcIakQQyWvLGgMxhgb-Svr9YWPMEQIMc8c14TQmWLL9xZIXcC32PJ1lHAi08cNeiADlcmfVYgnOk9Q-GskHbXTiccRbWMkGhXD7eGQMGhrB04CGLeK3ZHYMtaGtqLH8DZ5wbM2A5fq9i41v1AfHaASzUrIxkAxZGvzuTxTcMXhfrfEc0ZyEHBlB-TpKxLjO9N8_pQPMhBlaPNjj1AZrvkMFwW6xjyIwOyzWuHeNNZy26txCDfmnwcsS93aazlb87w6utGnqXt7gsOsBGm7pdJR-0i0><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在ArrayList的整个继承链中，通过最顶层的Iterable接口进行了约束。该接口中定义了iterator方法，用于返回Iterator实例。Collection接口通过对Iterable进行继承，实现对所有集合类的约束。Iterable接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免Collection接口在后续迭代的过程，影响到List相关接口对于Iterator的约束，因此List接口中同样定义了iterator方法，用于产生Itrator实例。同时为了实现针对List个性化的遍历需求，定义了ListIterator，实现了向前遍历的功能，同时增加了set与add相关方法。ListIterator接口仅适用于List类型的约束，如ArrayList、LinkedList等。ListIterator定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 前向遍历</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每一种具体的List类型的内部集合实现均不同，比如ArrayList内部使用数组，LinkedList内部使用链表。因此针对List的每一种具体类型，在其内部均定义了Iterator与ListIterator的具体实现。如Itr与ListItr实例的定义。业务在使用的List进行遍历时，面相接口编程，无需关系底层具体的迭代器实现逻辑。进行List类型的替换，也不会影响到业务遍历的逻辑。这也就是为什么迭代器模式实现复杂，还要引入该模式的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iterateVerify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 此处的ArrayList可以替换成LinkedList，不影响后面的迭代逻辑</span></span><br><span class="line">    <span class="comment">// List&lt;String&gt; list = new LinkedList&lt;&gt;();</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 集合数据添加</span></span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后向遍历</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前向遍历</span></span><br><span class="line">    ListIterator&lt;String&gt; listIterator = list.listIterator(list.size());</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">        System.out.println(listIterator.previous());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2024/12/09/Design-Pattern-of-Factory/"/>
      <url>/2024/12/09/Design-Pattern-of-Factory/</url>
      
        <content type="html"><![CDATA[<p>工厂模式是创建型模式的一种。通过提供创建对象的接口，而不是直接创建对象实例，使得代码更具扩展性和灵活性。根据对象创建的不同场景，工厂模式可以分为三类：简单工厂模式、工厂方法模式和抽象工厂模式。</p><span id="more"></span><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式通过一个单一的工厂类，根据不同参数，创建并返回不同的实例对象。通过简单工厂模式，可以将对象的创建逻辑封装起来，提供统一的接口给客户端使用，简化了客户端的代码复杂度，提高了代码的可维护性。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要创建的对象较少<br>当需要创建的对象较少时，可以考虑使用简单工厂模式来管理对象的创建过程。</li><li>对象的创建逻辑复杂<br>将对象的创建逻辑集中在一个工厂类中，可以简化客户端的代码，提高代码的可维护性。</li><li>不需要延迟创建对象<br>对象创建的逻辑在一个具体的工厂类中实现，对象的创建过程不需要延迟到子类中。</li></ul><h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><img  src=http://www.plantuml.com/plantuml/svg/dL7DIWCn4BxFKypH8ja7AAKWWk15XVO5OdQiWTsa9BDAiGNnhfvy00-29wzUV9tLrp3MTFg3IZ6dOURxcmcmvOhmu-MwlNreNv_QkvltvyVsxHx0EgPmfWtXuKdmPMCOhm3JsyK11-j6MFg1hsbudkgTplfeH7oaQvBsXRSbnjpCcDY16O0-ZHnq4j_BnRgPMYYwnFolXopGcnR5fX5i6lUcIk6-ToOGKsuUEzeADxpq0ARICVwWyFVzPhyGa-IMn8CKpeU9eEMqid_IrIByJLsGbEelSTsCb4YL9RVy__cbZNUngKKiH-F9cEQwcL8KVSdLnIRIwc35xslo2G00><p>以上图中各个角色的类说明如下表：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>产品接口：IProduct</td><td>定义了具体产品需要实现的基本功能与规则约束</td></tr><tr><td>抽象产品：AbstractProduct</td><td>实现了各个产品类需要实现的通用功能与约束</td></tr><tr><td>具体产品：ConcreteProductX</td><td>根据各个具体类自身的不同特点，扩展抽象产品并实现标准产品接口</td></tr><tr><td>工厂：Factory</td><td>提供生产具体产品的工厂接口</td></tr><tr><td>客户端：Client</td><td>使用工厂类提供的接口，根据不同的参数获取对应的实例对象。</td></tr></tbody></table><p>注<sup>1</sup>：在实际开发中，Product不一定会有以上UML图中抽象的层次那么深，需要根据实际场景进行考量。比如：直接实现具体产品类并没有AbstractProduct。<br>注<sup>2</sup>：Factory中定义的接口返回值不要返回具体类，要是使用标准的产品接口，遵循LSP原则。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>下面通过<code>mysql-connector-java:8.0.33</code>中获取ConnectionUrl的源码对简单工厂模式的具体实例进行分析。</p><h4 id="实例UML图"><a href="#实例UML图" class="headerlink" title="实例UML图"></a>实例UML图</h4><img  src=http://www.plantuml.com/plantuml/svg/ZP0nYW9H38Rxd2Ab8kC1L6mS5cnMK3n0V6J71qC6yh8sAeYjQ6ThPpkjdQVPmMlui794MDFc-_wV1CnRpdWhDzN-M5tErM5RbQU_wmx0Yx7-a6DCoMX6WQUQ3menyiAAIy0uBPoOUiamOtl26iqkh05e5ap96KPDs9al92u_KjzszbRjTZqBwiczLPBW5_cyMB1-3AOI9hhu5n_P_17gb8s74ep4CRoGIT9_kRQ3KI2Bv7SXOyvyY7-DTwVgO_TRuJSmt040><h4 id="代码具体实现"><a href="#代码具体实现" class="headerlink" title="代码具体实现"></a>代码具体实现</h4><p>为了实现与MySQL进行连接，NonRegisteringDriver通过connect方法获取java.sql.Connection实例。在该方法中，通过ConnectionUlr提供的getConnectionUrlInstance接口，获取到具体的ConnectionUrl实例。如：SingleConnectionUrl、FailoverConnectionUrl、LoadBlanceConnectionUrl等9个具体实例。客户端调用工厂类获取具体实例的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.sql.Connection <span class="title function_">connect</span><span class="params">(String url, Properties info)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ConnectionUrl.acceptsUrl(url)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * According to JDBC spec:</span></span><br><span class="line"><span class="comment">             * The driver should return &quot;null&quot; if it realizes it is the wrong kind of driver to connect to the given URL. This will be common, as when the</span></span><br><span class="line"><span class="comment">             * JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过简单工厂模式，根据url，info获取具体ConnectionUrl实例</span></span><br><span class="line">        <span class="type">ConnectionUrl</span> <span class="variable">conStr</span> <span class="operator">=</span> ConnectionUrl.getConnectionUrlInstance(url, info);</span><br><span class="line">        <span class="comment">// 后续通过ConnectionUrl构建并获取不同的java.sql.Connection实例</span></span><br><span class="line">        <span class="comment">// 其它内容省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedConnectionStringException e) &#123;</span><br><span class="line">        <span class="comment">// When Connector/J can&#x27;t handle this connection string the Driver must return null.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CJException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(UnableToConnectException.class,</span><br><span class="line">                Messages.getString(<span class="string">&quot;NonRegisteringDriver.17&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; ex.toString() &#125;), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>com.mysql.cj.conf.ConnectionUrl#getConnectionUrlInstance</code>方法中，实现了根据不同connString与info实例化ConnectionUrl的封装。具体实现中，根据不同的key将不同类型的ConnectionUrl缓存在本地。由于本地缓存使用非线程安全的LRUCache，为了提高性能实现了基于双检查锁的加锁逻辑。具体实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConnectionUrl <span class="title function_">getConnectionUrlInstance</span><span class="params">(String connString, Properties info)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connString == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(WrongArgumentException.class, Messages.getString(<span class="string">&quot;ConnectionString.0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">connStringCacheKey</span> <span class="operator">=</span> buildConnectionStringCacheKey(connString, info);</span><br><span class="line">    ConnectionUrl connectionUrl;</span><br><span class="line">    rwLock.readLock().lock();</span><br><span class="line">    connectionUrl = connectionUrlCache.get(connStringCacheKey);</span><br><span class="line">    <span class="keyword">if</span> (connectionUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">        rwLock.readLock().unlock();</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Check again, in the meantime it could have been cached by another thread.</span></span><br><span class="line">            connectionUrl = connectionUrlCache.get(connStringCacheKey);</span><br><span class="line">            <span class="keyword">if</span> (connectionUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ConnectionUrlParser</span> <span class="variable">connStrParser</span> <span class="operator">=</span> ConnectionUrlParser.parseConnectionString(connString);</span><br><span class="line">                <span class="comment">// 实例化并返回具体实例</span></span><br><span class="line">                connectionUrl = Type.getConnectionUrlInstance(connStrParser, info);</span><br><span class="line">                connectionUrlCache.put(connStringCacheKey, connectionUrl);</span><br><span class="line">            &#125;</span><br><span class="line">            rwLock.readLock().lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rwLock.readLock().unlock();</span><br><span class="line">    <span class="keyword">return</span> connectionUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式定义了一个用于创建对象的接口，但让子类决定实例化哪一个类，使一个类的实例化延迟到子类。父类决定实例的生成方式，但并不决定所要生成的具体类，具体的处理全部交给子类负责。这样就将实例生成框架和实际负责生成实例的类进行了解耦。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要创建的对象具有复杂的创建过程<br>如果一个对象的创建过程比较复杂，包含多个步骤，且这些步骤可以被定制或者扩展，那么使用工厂方法模式可以将复杂的创建过程封装在工厂方法中。该场景多数情况下，还会用到模板方法模式。</li><li>代码需要与具体类解耦<br>当代码中需要使用一些具体类的实例时，直接依赖这些具体类会使得代码变得脆弱，难以维护和扩展。工厂方法模式通过使用抽象类或者接口来定义创建对象的方法，可以将代码与具体类解耦。</li><li>需要在实例化时进行一些额外的操作<br>有时候在创建对象时需要进行一些额外的操作，比如设置默认值、进行依赖注入、执行一些初始化逻辑等。这些操作可以在工厂方法中进行，从而避免在每个使用对象的地方重复这些操作。</li><li>需要通过子类来选择需要创建的对象<br>如果系统中有多个子类，客户端需要根据不同的条件创建不同的子类实例，那么可以将创建对象的职责下放到子类中，通过子类来决定具体实例化哪个类。</li><li>需要创建产品对象的家族，且这些对象之间具有一定的关系<br>当需要创建一组相关的对象时，可以使用工厂方法模式来定义一个创建这些对象的接口，不同的子类实现该接口来创建具体的对象，从而保证这些对象之间的一致性和互操作性。</li></ul><h3 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h3><img  src=http://www.plantuml.com/plantuml/svg/dPF1IiD048Rl-nG3Nb9g5jfZAGKf25vKQ5zWJSOQQB9birN4UX7nu45FUl0Wv21u5wfI7wU9h-6cNTDqJMiq4BAxy_FDF_yIwSa-Glpw5DzS9FVloSjTyXp57xU4U854SSWSX2IwIXx7T6TVS7VeI3WZe9ugTAJmWXwulCDzx1wfjLLPBlLGxZ8Vi-DZxhaGwaEj2Ilad11s44h155mtszBxvPxsDpXG0FBVNawVXI5yJYwdat6DjddW29IeE-q5k7v00r0t0TqJ_YiWYx8veXICMOavUtDas_3JPYcTShCwt6trSd6QsSriAGBB4DQ02URNDc7shS_ptPZdEn3SGNSeKFcnYYlAWRKcTkqX7_igShKCkMwIy_VnPxAPr5B42-kbTBEhC8MstLh4tj31au9mIWdJMOk5EgFfsqDy7T5styCW_QdI6VM6qXQOxXem334lo85LvGi0><p>以上图中各角色的类说明如下表：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>产品接口：IProduct</td><td>定义了具体产品需要实现的基本功能与规则约束</td></tr><tr><td>抽象产品：AbstractProduct</td><td>实现了各个产品类需要实现的通用功能与约束</td></tr><tr><td>具体产品：ConcreteProductX</td><td>根据各个具体类自身的不同特点，扩展抽象产品并实现标准产品接口</td></tr><tr><td>抽象工厂：AbstractFactory</td><td>定义了IProduct的生产流程，具体的实现细节由子类去实现</td></tr><tr><td>具体工厂：ConcreateFactoryX</td><td>具体工厂实现抽象工厂定义的具体实现细节，生产具体的产品</td></tr><tr><td>客户端：Client</td><td>根据不同参数获取到具体工厂类，并通过工厂类方法生产指定的具体产品的实例对象。</td></tr></tbody></table><p>注<sup>1</sup>：工厂方法模式可以在工厂实现时同时采用模版方法模式，目的是对复杂的产品创建过程进行约束。<br>注<sup>2</sup>：尽管Java中接口中支持通过default定义方法的默认实现，但这里的抽象工厂采用抽象类而没有使用接口，是因为Java接口中定义的方法只能为public，对于需要子类去实现的方法不能进行访问权限的限制。在客户端也可以对相应的方法进行访问。<br>注<sup>3</sup>：在不需要约束产品流程时，抽象工厂也可以直接使用接口定义。</p><h3 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h3><p>下面通过<code>org.slf4j.LoggerFactory</code>中获取Logger的源码对工厂方法模式的具体实例进行分析。</p><h4 id="实例UML图-1"><a href="#实例UML图-1" class="headerlink" title="实例UML图"></a>实例UML图</h4><img  src=http://www.plantuml.com/plantuml/svg/XLAxJiCm5Dtz5HwBK39rAgWIhK12We9KVi19RbENr9RioniMLYGs6DbOMHWG2rz3-XqupTE9LJnPzvnpxxd79iWn0Pf-lQVFZwlNxzNdI_hnzllpH0WN26h6Gg3JPDPV-4SoZa7HEqBDsQPJL5p4D0QSi2NqjdQAUY1b0anGhi-K4UyB5YGGrVYbv1753EeLBPOwjb69Sr37W7CPwKpuG8XbOVVUzwcvZrXuNjGSXBmoEJbrCpolsYjaoANOks8AMjmEKitEM_KNXQ0Rrs6E7B0GfRgfOYlQcDZoMnc2C24sLst97IkFfPbuZHluhGGARFC0UwzIqd6rrdZUqFuR0negO0Y4EAsk1JPIIznc6pCggDPqdPOZx3KQniA4QMsvRhyG2tJsFN7pKxK_PTTlA-01lT3mZwJZTiHl_N72GQ2BbJLiCeRElNBU7m00><h4 id="代码具体实现-1"><a href="#代码具体实现-1" class="headerlink" title="代码具体实现"></a>代码具体实现</h4><p>客户端代码只依赖Slf4j包定义的Logger和LogFactory，避免了直接依赖具体的日志实现(如：LogBack)。这样在需要进行日志替换时，只需要变更相应配置即可，业务代码不需要进行改变。在ILoggerFactory接口中定义了日志生产的方法，具体的日志生产延迟到具体的日志工厂中。这些具体工厂在不同的日志框架中实现。在<code>org.slf4j.LoggerFactory#getLogger(java.lang.String)</code>方法中获取ILoggerFactory实例，根据具体的ILoggerFactory获取Logger实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getLogger</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="type">ILoggerFactory</span> <span class="variable">iLoggerFactory</span> <span class="operator">=</span> getILoggerFactory();</span><br><span class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ILoggerFactory的具体实例，在编译时进行绑定。如果发现有多个日志组件实现则抛出异常。根据绑定的具体日志组件通过<code>StaticLoggerBinder.getSingleton().getLoggerFacotry</code>得到具体的IFactory实例。在spring boot中的默认日志实现是通过spring-boot-starter-logging模块提供的。Spring Boot的自动配置机制（spring-boot-autoconfigure）会在运行时加载默认的日志配置。如果检测到多个日志实现，按优先级加载第一个可用的实现。默认情况下，Logback是第一个被检测到的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title function_">getILoggerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">        <span class="comment">// 加锁避免重复加载</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LoggerFactory.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class="line">                INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class="line">                <span class="comment">// 日志组件加载、bind核心方法</span></span><br><span class="line">                performInitialization();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class="line">        <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class="line">    <span class="keyword">case</span> NOP_FALLBACK_INITIALIZATION:</span><br><span class="line">        <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</span><br><span class="line">    <span class="keyword">case</span> FAILED_INITIALIZATION:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(UNSUCCESSFUL_INIT_MSG);</span><br><span class="line">    <span class="keyword">case</span> ONGOING_INITIALIZATION:</span><br><span class="line">        <span class="comment">// support re-entrant behavior.</span></span><br><span class="line">        <span class="comment">// See also http://jira.qos.ch/browse/SLF4J-97</span></span><br><span class="line">        <span class="keyword">return</span> SUBST_FACTORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unreachable code&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Boot的日志LoggingSystemFactory默认配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.logging.LoggingSystemFactory=\</span><br><span class="line">org.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\</span><br><span class="line">org.springframework.boot.logging.java.JavaLoggingSystem.Factory</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。这种模式有助于提高代码的灵活性和可扩展性，同时也使代码更易于维护和测试。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>一组相关或依赖对象一起使用，同一个工厂可以同时创建多个产品族产品实例。举个例子：我们要生产一辆汽车，这就需要发动机、轮胎、车架、车机等产品。这些产品都是相关的一族产品。</p><h3 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h3><img  src=http://www.plantuml.com/plantuml/svg/K-3YAiaioKbLUDQrzyN6XK-tBttQr_HinSAdU_gvk3BpIbABqXAJWR8BsvxDswRd6L2KdrAQNEAeKCsb00JQ2cNvcIaAkQab6Vaf6fhMNBLSNCavYSN52iztjppPlSrGppa_BxaejIGLfj4_BrMX6asL4OQgaF9yi2gS3d0Yrm5EH3d02UO0X8TjQlJq5B3uXf0Ie4a8Ovomgd52DWQ74h0ncC7XbfXSabzK2GyDX6E0kXCHhW053QeA9rGLJdW33seD_h23Ae877SnjAFv1c8HV0IJOO2fqTUsGl6O5TJfsUIU4F1SMzuEKOakKS4t4wN52qSE59GomMGGInsKH3ZrEA7gWGVzanwodNGlrd7CoK_DAmA4DPO830XOgLWgbnQaeCaX1Y4FA2Ie50000><p>以上图中各角色的类说明如下表：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>产品接口：IProductA、IProductB</td><td>定义不同产品族需要实现的基本功能与规则约束</td></tr><tr><td>具体产品：IProductA-X、IProductB-X</td><td>不同产品的具体实现实例</td></tr><tr><td>工厂接口：IFactory</td><td>定义不同产品族的生产流程(IProductA、IProductB)，具体细节由子类实现</td></tr><tr><td>具体工厂：ConcreteFactoryX</td><td>工厂接口的具体实现，生产具体的产品实例</td></tr><tr><td>客户端</td><td>调用具体的工厂，获取相应的产品实例</td></tr></tbody></table><p>注<sup>1</sup>：抽象工厂模式与工厂方法模式的区别在于，抽象工厂模式提供了不同产品族产品实例的生产，工厂方法模式用于同一产品族不同实例的生产。</p><h3 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h3><p>在实际应用中，抽象工厂模式比较典型的实现是java.sql包中的Connection等相关接口的定义和实现。在该包中定义了Statement、Blob、Clob、NClod、SQLX等一批接口。这一批接口可以理解为不同的抽象产品族。Connnection接口为抽象工厂类，在该接口中定义了生产Statement、Blob、Clob、NClod、SQLX等产品族产品的接口定义。不同的数据库驱动包分别定义了适用于自身数据库相关产品族实例的实现。</p><h4 id="实例UML图-2"><a href="#实例UML图-2" class="headerlink" title="实例UML图"></a>实例UML图</h4><img  src=http://www.plantuml.com/plantuml/svg/uoh9BCb9LNZMjVV5neLFjozzsjVqRCN2ftlwdwwRzsHVDnSNLsPUIMfHMc9oge9NObbYS66EddD-NbvgSabcVfv2DPS246Wh10VwHFZwA2GNfIQMf48u6feA9Hb5-UN584dNYkJK0f0EQvY64g32tDIy4fWU61-NjbfiBe5QMys5Gnfk2KG55W_ewjgXcsO5TH91vN3JuJgmQR6fqTDJSCxFzQqiBinnpl9AIKf6alRCBSZXmZGHcoQuBAeUYAEnQG2p8V9SN7XT0FONFkiGNYJP72HN415G_aNf0Vd59Ub5gK1TOFq1wGWrk48Acowu4gn1XLK7DAZmkm7iHxmM8hn9hadeeUMKMQNdd9C9CXiv1I8PPQLGMfoAInsooq3A0000><h4 id="代码具体实现-2"><a href="#代码具体实现-2" class="headerlink" title="代码具体实现"></a>代码具体实现</h4><p>代码实现相对比较简单，直接对着上面UML图看源码即可。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】[结城浩]. 图解设计模式[M]. 杨文轩译. 北京: 人民邮电出版社, 2017.1</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>生活工作在帝都，焊过板子、修过雷达、奋斗过大厂，目前在某银行从事架构相关工作。</p><p>性格比较安静，喜欢读书、跑步、撸码，享受那种忘我融于自然的状态。</p><p>安静中蕴藏一颗倔强的心，希望通过自己一步步的努力，完成自己的梦想！</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Github: <a href="https://github.com/dreamshield/">Dreamshield</a></li><li>Email: <a href="Mailto:zhpf@qq.com">zhpf@qq.com</a></li></ul><h2 id="公众账号"><a href="#公众账号" class="headerlink" title="公众账号"></a>公众账号</h2><img src="/img/common/subscribe-account.png" width="25%" style="float:left">]]></content>
      
    </entry>
    
    
  
</search>
